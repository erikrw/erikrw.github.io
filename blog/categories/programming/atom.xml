<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Erik Ramsgaard Wognsen]]></title>
  <link href="http://blog.erw.dk/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://blog.erw.dk/"/>
  <updated>2016-04-27T22:01:06+02:00</updated>
  <id>http://blog.erw.dk/</id>
  <author>
    <name><![CDATA[Erik Ramsgaard Wognsen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fun with Declarative Programming]]></title>
    <link href="http://blog.erw.dk/2015/12/06/fun-with-declarative-programming/"/>
    <updated>2015-12-06T19:36:41+01:00</updated>
    <id>http://blog.erw.dk/2015/12/06/fun-with-declarative-programming</id>
    <content type="html"><![CDATA[<p>My <a href="http://www.bachata-geek.me">girlfriend</a> introduced me to Eric Wastl&rsquo;s <a href="http://adventofcode.com">Advent of Code</a>,
a programming puzzle Advent calendar. The best advent calendar I&rsquo;ve had in my
adult life! (If you&rsquo;re planning on playing it, this article is one big spoiler
for Day 5.) I compare declarative programming puzzle solutions on readability
and speed.</p>

<!-- more -->


<p>The puzzle for Day 5 is:</p>

<blockquote><p>Santa needs help figuring out which strings in his text file are naughty or nice.</p>

<p>A nice string is one with all of the following properties:</p>

<ul>
<li>It contains at least three vowels (<code>aeiou</code> only), like <code>aei</code>, <code>xazegov</code>, or <code>aeiouaeiouaeiou</code>.</li>
<li>It contains at least one letter that appears twice in a row, like <code>xx</code>, <code>abcdde</code> (<code>dd</code>), or <code>aabbccdd</code> (<code>aa</code>, <code>bb</code>, <code>cc</code>, or <code>dd</code>).</li>
<li>It does not contain the strings <code>ab</code>, <code>cd</code>, <code>pq</code>, or <code>xy</code>, even if they are part of one of the other requirements.</li>
</ul>


<p></li>
</ul>


<p>How many strings are nice?</p></blockquote>

<p>On the <a href="http://adventofcode.com">page</a> you get more explanation and an input to use for your
code, but this is the basic challenge.</p>

<p>I&rsquo;d normally do this in Python, but I&rsquo;m brushing up on my C#-fu, so that&rsquo;s what
I went with. I first wrote it in classic, imperative style:</p>

<pre><code class="CSharp">using System;
using System.IO;

namespace Day5
{
  class MainClass
  {
    public static void Main()
    {
      var nNice = 0;

      foreach (var line in File.ReadLines("../../input"))
      {
        if (line.Contains("ab") ||
            line.Contains("cd") ||
            line.Contains("pq") ||
            line.Contains("xy"))
        {
          continue;
        }

        var vowels = 0;
        foreach (var character in line)
        {
          if ("aeiou".Contains(character))
          {
            vowels++;
          }
        }
        if (vowels &lt; 3)
        {
          continue;
        }

        foreach (var character in line)
        {
          if (line.Contains(new string(character, 2)))
          {
            nNice++;
            break;
          }
        }
      }
      Console.WriteLine(nNice);
    }
  }
}
</code></pre>

<p>One of the reasons I love Python is <a href="https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions">comprehensions</a>. But
.NET has <a href="https://msdn.microsoft.com/en-us/library/bb397926.aspx">LINQ</a> (Language Integrated Query), which I one of the reasons
I love C# too. By <code>using System.Linq</code> I can turn the <code>Main()</code> body into
a single, declarative statement:</p>

<pre><code class="CSharp">      Console.WriteLine(
        File.ReadLines("../../input")
        .Count(line =&gt;
          line.Count(character =&gt; "aeiou".Contains(character)) &gt;= 3 &amp;&amp;
          line.Any(character =&gt; line.Contains(new string(character, 2))) &amp;&amp;
          !(new[] { "ab", "cd", "pq", "xy" }.Any(naughty =&gt; line.Contains(naughty)))));
</code></pre>

<p>It sure feels good to write compact code, but is it better than the imperative
version?
It depends on how you evaluate it.</p>

<p></p>

<a name="Readability"></a>
<h2>Readability</h2>

<p>Imperative code always requires detailed inspection and/or non-outdated
comments to understand. On the other hand, I think the gist of the declarative
version is very quick to read: &ldquo;Count the number of lines in the input file
which satisfy &hellip; some criteria&rdquo;. Compared to the imperative version, the
overall purpose is much clearer. But the individual criteria still take time to
read.</p>

<p></p>

<pre><code class="CSharp">          line.Count(character =&gt; "aeiou".Contains(character)) &gt;= 3 &amp;&amp;
          line.Any(character =&gt; line.Contains(new string(character, 2))) &amp;&amp;
          !(new[] { "ab", "cd", "pq", "xy" }.Any(naughty =&gt; line.Contains(naughty)))
</code></pre>

<p>At least three vowels, a repeated character, and no naughty substrings.</p>

<p>The keen reader may have noticed that the first criterion could be written more
compactly as <code>line.Count("aeiou".Contains) &gt;= 3</code> (similarly with the third).
I think this is less readable, and compactness is not a goal in itself, unless
you are playing code golf. Incidentally, the method group (compact) version
also performs slightly slower.</p>

<p>Variable names are a form of built-in documentation. Along the same lines, it
might help to introduce variables:</p>

<pre><code class="CSharp">      var vowels = "aeiou";
      var naughtySubstrings = new[] { "ab", "cd", "pq", "xy" };
</code></pre>

<p>But readability also depends on what you know.
For the uninitiated, <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a> are complete gibberish. But
for the experienced, <code>using System.Text.RegularExpressions</code> can actually state
the criteria more clearly. Instead of fussing over the individual characters of
the line and naughty patterns, it is easier to compare the whole, undivided
line to a pattern:</p>

<pre><code class="CSharp">          Regex.Matches(line, "[aeiou]").Count &gt;= 3 &amp;&amp;
          Regex.IsMatch(line, @"(.)\1") &amp;&amp;
          !Regex.IsMatch(line, "ab|cd|pq|xy")
</code></pre>

<p>Regular expressions are declarative on an even higher level.</p>

<p>But they might not perform that well, especially when using uncompiled regular
expressions. And that leads us to another criterion.</p>

<a name="Performance"></a>
<h2>Performance</h2>

<p>Doing a quick benchmark on an input with two million strings and warmed-up
caches, the uncompiled Regex version completes in 6.6 seconds, the LINQ version
in 4.4 seconds, and my naive imperative version in 2.4 seconds. So much for
readability. (This was using Mono, btw.)</p>

<p>But, the declarative style has a trick up its sleeve: Parallelism for free!</p>

<pre><code class="CSharp">      Console.WriteLine(
        File.ReadLines("../../input")
        .AsParallel()  ///////////////////////////////// Parallelism for free!
        .Count(line =&gt;
          line.Count(character =&gt; "aeiou".Contains(character)) &gt;= 3 &amp;&amp;
          line.Any(character =&gt; line.Contains(new string(character, 2))) &amp;&amp;
          !(new[] { "ab", "cd", "pq", "xy" }.Any(naughty =&gt; line.Contains(naughty)))));
</code></pre>

<p>1.8 seconds on my quadcore!</p>

<p></p>

<p>Now, I have not optimized any of these three versions for performance, and it
could of course be done faster in C# (with or without explicit threads), and
most likely even faster in C or C++.</p>

<p>So I think the conclusion so far is what it is nothing new:
Readability and performance are conflicting goals.</p>

<a name="Debuggability"></a>
<h2>Debuggability</h2>

<p>One final criterion is debuggability. I have loved declarative style for a long
time, but always found it harder to debug than imperative style. However, an
advantage of Python and C# compared to, say, Haskell, is that they are
basically imperative languages with other paradigms on top. Thus, you can
gradually learn declarative and functional style in the safe context of
imperative programming. And cut down on the declarative-ness when you want to.</p>

<p>However, next up on my reading list is <a href="https://www.simple-talk.com/dotnet/.net-framework/linq-secrets-revealed-chaining-and-debugging/">LINQ Secrets Revealed: Chaining and Debugging</a>.</p>

<a name="Python.Postscript"></a>
<h2>Python Postscript</h2>

<p>I did the puzzle in Python just to see how it compared. Rather than reading
then length of a list made with a list comprehension, I do it in a streaming
fashion by summing over a generator expression:</p>

<pre><code class="Python">import re
print sum(1 for line in open("input").readlines()
          if (len(re.findall('[aeiou]', line)) &gt;= 3 and
              re.search(r'(.)\1', line) and
              not re.search('ab|cd|pq|xy', line)))
</code></pre>

<p></p>

<p>(This is the whole program, not just the body of some main function!)</p>

<p>At 5.3 seconds for the two million strings, this stacks up pretty well against
C#, considering that Python is interpreted.</p>

<p><em>Update 2016-03-12: I added in the performance section that I used Mono.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ode to my Casio]]></title>
    <link href="http://blog.erw.dk/2015/07/11/ode-to-my-casio/"/>
    <updated>2015-07-11T13:57:20+02:00</updated>
    <id>http://blog.erw.dk/2015/07/11/ode-to-my-casio</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/posts/casio.jpg" width="345"></p>

<p>The year was 2002 and I had started gymnasium (≈high school). My parents had
bought me the graphic calculator required for our maths classes: Casio fx-9750G
PLUS. It was white and green and curvy and Casio &mdash; not dark and rectangular
and from Texas Instruments, as a calculator was expected to be. Soon, however,
this happy-looking thing became my companion on my journey into the world of
programming.</p>

<!-- more -->


<p></p>

<p></p>

<p>Compared with a personal computer, this calculator was weak, to say the least.
The display resolution was 128×64 pixels in black and white. (However, I did
for a long time dream of the color LCD version CFX-9850GC PLUS, which could
show <em>three</em> colors:
<span style="color:orange">orange</span>,
<span style="color:green">green</span>, and
<span style="color:blue">blue</span>.)
The processor was slow. Graphing <em>y = x<sup>2</sup></em> took a good five seconds. Sinusoidal
regression on 150 data points took 75 seconds, plus another 8 seconds to draw
the sine curve.
Memory was limited as well: 32K, of which only 28568 bytes were available to
the user. And of which every list and matrix entry took up 10 bytes! Plus, any
time something was graphed, 4K was reserved for that.
</p>

<p>Yet for all these complaints, this machine was a fantastic place to start
programming. Having a fixed set of features challenges you to do what you can
with what you have. On this fixed platform, there was no getting lost in
debates about which programming language to use, because there was only one
choice. There was no trouble with installation or incompatible software
libraries. There was no web browsing or multitasking. No distraction. And zero
boot time and a year of battery life.</p>

<p><img class="right" src="/images/posts/casio-fact.jpg"></p>

<p>The basic calculator part is a REPL: That is to say it <em>reads</em> your input,
<em>evaluates</em> it, <em>prints</em> the result, and it <em>loops</em>, doing this indefinitely.
In this interactive environment, you can familiarize yourself with expressions
before slowly, step by step, automating small parts of your calculations. You
could, for example, make a small program that asks the user for input and uses
a loop to do a calculation.</p>

<p></p>

<p>And there were enough features to do really cool things: Plotting, lists and
list operations (sorting, summation, product, mean, median, etc.), matrices and
matrix operations, statistics, regression, etc.</p>

<p></p>

<a name="Programming.on.the.Bus"></a>
<h2>Programming on the Bus</h2>

<p>During the bus trips to school I spent as much time with my Casio as people
today spend with their smartphones. And I suppose this puzzled the other
students: How much time can you really spend calculating?</p>

<p>I made programs for all sorts of tasks. One type was the programs that helped
my maths and science classes. In maths it was nice to be able to enter the
information you had about a triangle, and then calculate the rest
automatically. Or calculate the greatest common divisor. In physics,
I calculated and visualized refraction. In chemistry, I calculated molar
masses.</p>

<p><img class="right" src="/images/posts/casio-guitar.jpg"></p>

<p>But it was also fun and games: I made programs that drew nice geometric shapes
for their beauty. I calculated poker odds. During some boring classes I made
a program in which you entered the time of day (the calculator didn&rsquo;t have
a clock), and it drew a 3d pie chart showing how close the current lecture was
to completion. And I factored out the pie chart so other programs could use it
as a subroutine.</p>

<p>I made programs for sound and music. I translated between notes (such as A) and
frequencies (such as 440 Hz). I visualized harmonics. I made a program that
showed all the ways a chosen note could be played on a guitar. (And
I didn&rsquo;t even play the guitar!)</p>

<p>And I made games. Guess which number I&rsquo;m thinking of, where the program tells
you whether your guess was too high or too low. I made a game in which you had
to remember random numbers that were shown in progressively shorter glimpses.
Each level made the number one digit longer. I made Snake. It grew linearly
slower with the length of the snake, and the game was too slow to be fun to
play. But that didn&rsquo;t affect my pride in making it. Near the end of gymnasium,
I was planning a strategy game inspired by Command &amp; Conquer Tiberian Sun,
which I loved. I had a cool animation for the cyborgs&#8217; machine guns, but other
than that, I never got very far. But to be fair, it is a rather big step from
Snake to that.</p>

<a name="Much.Learnage"></a>
<h2>Much Learnage</h2>

<p>This primitive programming taught me some lessons about &ldquo;real&rdquo; programming:</p>

<ul>
<li>Understanding a program you wrote months ago is tricky, when all variable
names are a single character. I learned the value of descriptive variable
names.</li>
<li>The slow processor gave me a tangible sense of execution time and complexity.</li>
<li>With an editor window of 6x21 chars, I soon learned that sketching your
algorithm or architecture before implementing is useful for big programs.
That would probably take more time to learn on a big screen.</li>
<li>I learned to prioritize what to do with the limited memory.</li>
<li>I learned debugging the hard way: There were almost no meaningful error
messages (but at least you could be taken to the location in the code that
caused the error).</li>
<li>I learned that all programs and subroutines sharing a global address space
sucks!</li>
</ul>


<p></p>

<a name="Interacting.with.the.World"></a>
<h2>Interacting with the World</h2>

<p>After some time, interacting with a program through a (tiny) screen and (tiny)
keyboard was not enough. I wanted to interact with the world. Thankfully, my
parents got me the Casio EA-200 data logger. This device was even clunkier than
the calculator, but it was a window to the physical world: Now I could measure
voltage, light, temperature, and sound.</p>

<p>I measured the fluctuation of the temperature in the fridge. Since I could hear
the compressor swiching on and off I knew the temperature couldn&rsquo;t be constant,
so I wanted to know the extent of the lie that &ldquo;a fridge is 5&#x00b0;C&rdquo;. (As
I recall, it went between 4 and 8&#x00b0;C). Knowledge is power, even in the
small.</p>

<p>With the microphone and speaker, I made a dictaphone. As with Snake, the idea
of making it was more important than its usefulness. It did work, but the
memory was somewhat limited.</p>

<p>I also measured the fluctuation of the intensity of light from lightbulbs. Even
when they appear constantly on, they heat and cool with the alternating current
of the electric grid. And I learned about another &ldquo;truth&rdquo;: Our electric grid
runs at 50 Hz. Yes, when it&rsquo;s not 49 and 52 and 50.2 Hz. This is also where
I got to appreciate the Fourier transform that I recently <a href="/2015/03/20/debugging-complex-numbers/">implemented</a>
myself.</p>

<p>My dear Casio, thanks for the ride.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Checks for Your Django Project]]></title>
    <link href="http://blog.erw.dk/2015/06/06/checks-for-your-django-project/"/>
    <updated>2015-06-06T13:42:14+02:00</updated>
    <id>http://blog.erw.dk/2015/06/06/checks-for-your-django-project</id>
    <content type="html"><![CDATA[<p>The <a href="https://www.djangoproject.com/">Django web framework</a> has a management
command to <a href="https://docs.djangoproject.com/en/1.8/ref/checks/">check</a> your code for various problems. For
example, it checks that your database <code>CharFields</code> define the <code>max_length</code>
attribute, and that you have not set <code>DEBUG = True</code> in deployment. This is good
for catching various mistakes in using the framework before the problem shows
up in production. And for your own business logic, you have unit tests. But
there are still many things to not mess up, and they are easy to forget if they
are not incredibly easy to check. So I wrote a script to check every problem
I could think of in one go.</p>

<!-- more -->


<p></p>

<p>First up is the unit tests. For this script I only want it to tell me anything
if there is a problem, as is customary for unix programs. With verbosity 0 and
<code>head -n -4</code> cutting off the last four lines with the test summary, only failed
test cases are shown:</p>

<pre><code class="bash">./manage.py test -v 0 --noinput 2&gt;&amp;1 | head -n -4
</code></pre>

<p>Alternatively, you can run them with a code coverage check. Here, failed tests
are shown and the total code coverage is shown if it is below 50%:</p>

<pre><code class="bash">coverage run --branch --source='.' --omit='*/migrations/*,*test*,*settings*' \
    manage.py test -v 0 2&gt;&amp;1 | head -n -4
coverage report --fail-under=50 &gt;/dev/null || coverage report | sed -n '1p;$p' &amp;&amp; echo
</code></pre>

<p>The first of the &ldquo;hidden&rdquo; things that is easy to forget is changes to the data
model that need to be migrated in the database. Unfortunately, the
<code>makemigrations</code> management command doesn&rsquo;t have a usable exit status, but
I work around that to only output text in case of problems:</p>

<pre><code class="bash">[ "$(./manage.py makemigrations --dry-run)" != "No changes detected" ] &amp;&amp; \
    ./manage.py makemigrations --dry-run &amp;&amp; echo
</code></pre>

<p>I also run <a href="https://flake8.readthedocs.org/">flake8</a> which wraps the code style checker <a href="http://pep8.readthedocs.org/en/latest/intro.html">pep8</a>,
the static error checker <a href="https://pypi.python.org/pypi/pyflakes">Pyflakes</a>, and, optionally,
the <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity">code complexity</a> checker <a href="https://pypi.python.org/pypi/mccabe">mccabe</a>, if
you give the flag <code>--max-complexity=10</code>.</p>

<pre><code class="bash">flake8 . || echo
</code></pre>

<a name="Translation"></a>
<h2>Translation</h2>

<p>For a multilingual project, you must remember to scan for changes to
translatable strings and also to translate them. The <code>makemessages</code> management
command goes over the source and finds all strings marked for translation and
makes or updates the translation &ldquo;portable object&rdquo;/PO file. So ideally, I could
just run that command and see if there are any changes to the PO file.</p>

<p>However, <code>makemessages</code> includes a timestamp for the generation of the file, so
it is always different each time the command is run. On top of that, it can
happen that the command finds the translatable strings in a different order
even when the content of the strings didn&rsquo;t change (I think this happens
between different version of Django).</p>

<p>So, I compare the before and after versions of the PO file with the timestamps
stripped out, and sorted such that ordering doesn&rsquo;t matter. This sorting trick
will cause false negatives if two strings are swapped in the source code, but
this seems unlikely and therefore preferable to getting false positives from
<code>makemessages</code>&#x2019; inability to search the source in a consistent order.</p>

<pre><code class="bash">sed '/POT-Creation-Date/d' locale/da/LC_MESSAGES/django.po &gt; __po1
mv locale/da/LC_MESSAGES/django.po{,_orig}
cp locale/da/LC_MESSAGES/django.po{_orig,}
./manage.py makemessages -v 0 -a --no-location --no-obsolete
sed '/POT-Creation-Date/d' locale/da/LC_MESSAGES/django.po &gt; __po2
mv locale/da/LC_MESSAGES/django.po{_orig,}
diff &lt;(sort __po1) &lt;(sort __po2) &gt;/dev/null || \
    { echo "=== Translation not up to date:" &amp;&amp; diff __po1 __po2 || echo; }
rm __po1 __po2
</code></pre>

<p>Before and after running <code>makemessages</code>, I backup the PO file and restore it,
respectively. By doing this as <code>mv A B; cp B A; mv B A</code>, rather than just <code>cp
A B; mv B A</code>, the file retains its inode. Thus, editors will not falsely see
the file as changed outside the editor.</p>

<p>Even if you had already run <code>makemessages</code>, you also had to translate the newly
found strings. I check for both untranslated strings and unverified automatic
translations. The former appear as <code>msgstr ""</code>, but not every <code>msgstr ""</code> means
you forgot a translation; some of them just mark the beginning of a string
spanning multiple lines. So I do some <code>sed</code> magic to find the real culprits:</p>

<pre><code class="bash">sed '$a\\' locale/da/LC_MESSAGES/django.po | tac | \
    sed '/^$/N;/\nmsgstr ""$/,/^msgid/!d' | tac
</code></pre>

<p>While scanning, if <code>makemessages</code> finds a string that is close to something you
already translated, it will insert the existing translation and mark it as
a &ldquo;fuzzy&rdquo; match, so you can check it and remove the fuzzy label when the
translation is done. I find such unremoved &ldquo;fuzzy&rdquo; labels:</p>

<pre><code class="bash">[ $(grep -c ', fuzzy' locale/da/LC_MESSAGES/django.po) -gt 1 ] &amp;&amp; \
    echo "=== Fuzzy translation:" &amp;&amp; \
    grep ', fuzzy' locale/da/LC_MESSAGES/django.po -A2 | tail -n +5 &amp;&amp; echo
</code></pre>

<a name="The.Full.Script"></a>
<h2>The Full Script</h2>

<p>With all the components of the script done, the whole script looks like this.
I call it <code>ok.sh</code>:</p>

<pre><code class="bash">#!/bin/bash
coverage run --branch --source='.' --omit='*/migrations/*,*test*,*settings*' \
    manage.py test -v 0 2&gt;&amp;1 | head -n -4
coverage report --fail-under=50 &gt;/dev/null || coverage report | sed -n '1p;$p' &amp;&amp; echo

[ "$(./manage.py makemigrations --dry-run)" != "No changes detected" ] &amp;&amp; \
    ./manage.py makemigrations --dry-run &amp;&amp; echo

flake8 . || echo

sed '/POT-Creation-Date/d' locale/da/LC_MESSAGES/django.po &gt; __po1
mv locale/da/LC_MESSAGES/django.po{,_orig}
cp locale/da/LC_MESSAGES/django.po{_orig,}
./manage.py makemessages -v 0 -a --no-location --no-obsolete
sed '/POT-Creation-Date/d' locale/da/LC_MESSAGES/django.po &gt; __po2
mv locale/da/LC_MESSAGES/django.po{_orig,}
diff &lt;(sort __po1) &lt;(sort __po2) &gt;/dev/null || \
    { echo "=== Translation not up to date:" &amp;&amp; diff __po1 __po2 || echo; }
rm __po1 __po2

sed '$a\\' locale/da/LC_MESSAGES/django.po | tac | \
    sed '/^$/N;/\nmsgstr ""$/,/^msgid/!d' | tac

[ $(grep -c ', fuzzy' locale/da/LC_MESSAGES/django.po) -gt 1 ] &amp;&amp; \
    echo "=== Fuzzy translation:" &amp;&amp; \
    grep ', fuzzy' locale/da/LC_MESSAGES/django.po -A2 | tail -n +5 &amp;&amp; echo
</code></pre>

<p>There is no explicit call to <code>./manage.py check</code> because it is called
implicitly by the other management commands. An ideal run of the script
produces no output, but if you made a lot of errors, it could look like this:</p>

<pre><code class="plain">$ ./ok.sh 
======================================================================
FAIL: test_basic_addition (docs.tests.SimpleTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/home/erw/hstareal/docs/tests.py", line 16, in test_basic_addition
    self.assertEqual(1 + 1, 3)
AssertionError: 2 != 3

Migrations for 'requisitions':
  0002_auto_20150605_1757.py:
    - Alter field supplier_postcode on requisition

./requisitions/models.py:123:80: E501 line too long (108 &gt; 79 characters)
./requisitions/admin.py:194:25: F821 undefined name 'messages'
./requisitions/admin.py:441:25: F821 undefined name 'messages'

=== Translation not up to date:
1541c1541,1543
&lt; msgid "postcode"
---
&gt; #, fuzzy
&gt; #| msgid "postcode"
&gt; msgid "postal code"

=== Fuzzy translation:
#, fuzzy
msgid "internal account type"
msgstr "interne kontotyper"
</code></pre>

<p>Now, all that is required is to run this one script before committing. A CI
server could of course be nice, but for a small project, this might be fine,
and cheaper.</p>

<p>One thing that is missing is to make the check in lines 18&ndash;19 of the script
aware of untranslated strings that you don&rsquo;t need to translate in your own
project, because they are covered in Django&rsquo;s own translation. For example, my
404 page says &ldquo;Page not found&rdquo; which Django already knows how to translate into
70+ languages. The script could also be generalized to process all locales &mdash;
right now it is hardcoded for Danish.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Complex Numbers]]></title>
    <link href="http://blog.erw.dk/2015/03/20/debugging-complex-numbers/"/>
    <updated>2015-03-20T20:34:38+01:00</updated>
    <id>http://blog.erw.dk/2015/03/20/debugging-complex-numbers</id>
    <content type="html"><![CDATA[<p>For my research I needed to implement a <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform">discrete Fourier transform</a> in
the C-like programming language of the <a href="http://www.uppaal.org/">UPPAAL</a> model checker. One
option would be to port an existing C library such as <a href="http://www.fftw.org">FFTW</a>, but for
a proof of concept, porting a large, powerful library would be much slower
and less instructive than implementing a simpler algorithm myself.
Programming rant coming up.</p>

<!-- more -->


<p>I went with the <a href="http://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm#The_radix-2_DIT_case">Cooley-Tukey radix-2 decimation-in-time fast Fourier transform</a>,
which, despite the name, is one of the simpler choices.
Pseudocode adapted from Wikipedia:</p>

<p></p>

<pre><code>X[0,...,N−1] ← ditfft2(x, N, s):             DFT of (x[0], x[s], x[2s], ..., x[(N-1)s]):
    if N = 1 then
        X[0] ← x[0]                                  trivial size-1 DFT base case
    else
        X[0,...,N/2−1] ← ditfft2(x, N/2, 2s)         DFT of (x[0], x[2s], x[4s], ...)
        X[N/2,...,N−1] ← ditfft2(x+s, N/2, 2s)       DFT of (x[s], x[s+2s], x[s+4s], ...)
        for k = 0 to N/2−1                           combine DFTs of two halves into full DFT:
            t ← X[k]
            X[k] ← t + exp(−2πi k/N) X[k+N/2]
            X[k+N/2] ← t − exp(−2πi k/N) X[k+N/2]
        endfor
    endif

Here, ditfft2(x,N,1), computes X=DFT(x) out-of-place by a radix-2 DIT FFT,
where N is an integer power of 2 and s=1 is the stride of the input
x array. x+s denotes the array starting with xs.
</code></pre>

<p>I decided to handle the problem in two stages: 1) Implement the algorithm in
a high-level language (Python) to make sure I get the algorithm itself right,
and 2) reduce the use of high-level features until it is trivial to port to
a C-like language.</p>

<p>List handling in Python is always a charm, but the main high-level feature
I wanted was the handling of <a href="http://en.wikipedia.org/wiki/Complex_number">complex numbers</a> (notice the <code>−2πi</code>s
above). My first high-level version worked nicely &mdash; at least as compared with
the <code>fft</code> function of <a href="https://en.wikipedia.org/wiki/R_%28programming_language%29">R</a> with a few sample inputs. Code:</p>

<pre><code class="Python">import math
EVEN = 0
ODD = 1

def fft1(a):
    n = len(a)
    if n == 1:
        return a
    c = fft1(a[EVEN::2]) + fft1(a[ODD::2])
    for k in range(n / 2):
        t = c[k]
        c[k]         = t + pow(math.e, -2j * math.pi * k / n) * c[k + n / 2]
        c[k + n / 2] = t - pow(math.e, -2j * math.pi * k / n) * c[k + n / 2]
    return c
</code></pre>

<p>Next step was to handle the complex numbers manually, so they can be
represented by two doubles. At first I tried to handle the general case of
raising a real to a complex, but that was harder than I thought it would be.
Luckily my colleague Louise could derive it for me:</p>

<pre><code> a + bi      a                   a
x        =  x  cos(b ln(x)) + i x  sin(b ln(x))
</code></pre>

<p>(and I wish adding MathJax (LaTeX) to Octopress was a one-minute job, but it isn&rsquo;t.)</p>

<p>However, if I had remembered that in my case <em>x</em> = <em>e</em> and <em>a</em> = 0, it would
have been simpler. It even has a name, <a href="http://en.wikipedia.org/wiki/Euler%27s_formula">Euler&rsquo;s formula</a>, and it is
mindboggling in all its simple beauty:</p>

<pre><code> bi
e    =  cos(b) + i sin(b)
</code></pre>

<p>At least we both learned something about complex numbers!</p>

<p>The next (buggy) version of my code was this:</p>

<pre><code class="Python">def fft2(a_re, a_im):
    n = len(a_re)
    assert n == len(a_im)
    if n == 1:
        return (a_re, a_im)
    c_re, c_im = fft2(a_re[EVEN::2], a_im[EVEN::2])
    c_re2, c_im2 = fft2(a_re[ODD::2], a_im[ODD::2])
    c_re += c_re2
    c_im += c_im2
    for k in range(n / 2):
        t_re, t_im = c_re[k], c_im[k]

        c_re[k] = t_re + math.cos(-2 * math.pi * k / n) * c_re[k + n / 2]
        c_im[k] = t_im + math.sin(-2 * math.pi * k / n) * c_im[k + n / 2]
        c_re[k + n / 2] = t_re - math.cos(-2 * math.pi * k / n) * c_re[k + n / 2]
        c_im[k + n / 2] = t_im - math.sin(-2 * math.pi * k / n) * c_im[k + n / 2]

    return (c_re, c_im)
</code></pre>

<p>It didn&rsquo;t give the same output as the first one, and I couldn&rsquo;t see why, so
I put both versions in one to debug them in lockstep:</p>

<pre><code class="Python">def fft3(a, a_re, a_im):
    n = len(a)
    assert n == len(a_re) == len(a_im)
    if n == 1:
        return (a, a_re, a_im)
    c, c_re, c_im = fft3(a[EVEN::2], a_re[EVEN::2], a_im[EVEN::2])
    c2, c_re2, c_im2 = fft3(a[ODD::2], a_re[ODD::2], a_im[ODD::2])
    c += c2
    del c2
    c_re += c_re2
    del c_re2
    c_im += c_im2
    del c_im2
    for k in range(n / 2):
        t, t_re, t_im = c[k], c_re[k], c_im[k]

        c[k]         = t + pow(math.e, -2j * math.pi * k / n) * c[k + n / 2]
        c[k + n / 2] = t - pow(math.e, -2j * math.pi * k / n) * c[k + n / 2]

        c_re[k]         = t_re + math.cos(-2 * math.pi * k / n) * c_re[k + n / 2]
        c_im[k]         = t_im + math.sin(-2 * math.pi * k / n) * c_im[k + n / 2]
        c_re[k + n / 2] = t_re - math.cos(-2 * math.pi * k / n) * c_re[k + n / 2]
        c_im[k + n / 2] = t_im - math.sin(-2 * math.pi * k / n) * c_im[k + n / 2]

    return (c, c_re, c_im)
</code></pre>

<p>Testing still showed that the approaches disagreed:</p>

<pre><code class="Python">a = [1, 2, 1, 0]
x1, x2_re, x2_im = fft3(map(complex, a), a, [0] * len(a))
x2 = [complex(re, im) for re, im in zip(x2_re, x2_im)]
for x, y in zip(x1, x2):
    print x, y, x - y, '!' * 10 if x - y != 0 else ''
</code></pre>

<pre><code>(4+0j) (4+0j) 0j 
(1.22464679915e-16-2j) (1.22464679915e-16+0j) -2j !!!!!!!!!!
0j 0j 0j 
(-1.22464679915e-16+2j) (-1.22464679915e-16+0j) 2j !!!!!!!!!!
</code></pre>

<p>Stepping through the code in Winpdb, I found three things:</p>

<ul>
<li>Debugging is easier if you clean up temp variables in the namespace, hence
the <code>del</code> statements in <code>fft3</code>.</li>
<li>Debugging is easier if the complex numbers are represented as complex numbers
all the time, hence the test code giving <code>map(complex, a)</code> as the first
argument to <code>fft3</code> (rather than simply giving <code>a</code>).</li>
<li>Line 21 was the first to show the bug (for the given input): I had been so
focused on complex exponentiation that I had forgot all about
<a href="http://en.wikipedia.org/wiki/Complex_number#Multiplication_and_division">complex multiplication</a>! Which is btw

<ul>
<li>(a + bi) (c + di) = (ac - bd) + (bc + ad) i</li>
</ul>
</li>
</ul>


<p>Now I (naively hoped I) was done. Replacing</p>

<pre><code class="Python">c_re[k]         = t_re + math.cos(-2 * math.pi * k / n) * c_re[k + n / 2]
c_im[k]         = t_im + math.sin(-2 * math.pi * k / n) * c_im[k + n / 2]
c_re[k + n / 2] = t_re - math.cos(-2 * math.pi * k / n) * c_re[k + n / 2]
c_im[k + n / 2] = t_im - math.sin(-2 * math.pi * k / n) * c_im[k + n / 2]
</code></pre>

<p>by</p>

<pre><code class="Python">p_re = math.cos(-2 * math.pi * k / n)
p_im = math.sin(-2 * math.pi * k / n)
c_re[k]         = t_re +  (p_re * c_re[k + n / 2]) - (p_im * c_im[k + n / 2])
c_im[k]         = t_im +  (p_im * c_re[k + n / 2]) + (p_re * c_im[k + n / 2])
c_re[k + n / 2] = t_re - ((p_re * c_re[k + n / 2]) - (p_im * c_im[k + n / 2]))
c_im[k + n / 2] = t_im - ((p_im * c_re[k + n / 2]) + (p_re * c_im[k + n / 2]))
</code></pre>

<p>still didn&rsquo;t work. But that is just a silly bug: Reading <code>c_re[k + n / 2]</code> in
line 6 after it was overwritten in line 5. Python has a really nice solution
for problems like this: Do both <a href="https://docs.python.org/2/reference/simple_stmts.html#assignment-statements">assignments</a> at once!
Instead of lines 5 and 6:</p>

<pre><code class="Python">c_re[k + n / 2], c_im[k + n / 2] = (
    t_re - ((p_re * c_re[k + n / 2]) - (p_im * c_im[k + n / 2])),
    t_im - ((p_im * c_re[k + n / 2]) + (p_re * c_im[k + n / 2])),
)
</code></pre>

<p>However, the goal was using fewer high-level features, so my final solution
factors out the reused parts of the computation, which probably makes the code
simpler in this case anyway:</p>

<pre><code class="Python">p_re = math.cos(-2 * math.pi * k / n)
p_im = math.sin(-2 * math.pi * k / n)
mult_re = (p_re * c_re[k + n / 2]) - (p_im * c_im[k + n / 2])
mult_im = (p_im * c_re[k + n / 2]) + (p_re * c_im[k + n / 2])
c_re[k]         = t_re + mult_re
c_im[k]         = t_im + mult_im
c_re[k + n / 2] = t_re - mult_re
c_im[k + n / 2] = t_im - mult_im
</code></pre>

<p>So, after a few detours I got my &ldquo;manually&rdquo; computed complex numbers, and
learned a bit more about how complex numbers and FFTs work. Also, debugging
with a debugger (rather than print statements) doesn&rsquo;t mean you don&rsquo;t need to
modify your code &ndash; in my case, merging both functions made the debugging a lot
easier.</p>

<p>Finally, the Python <a href="https://docs.python.org/2/library/math.html"><code>math</code> library</a> doesn&rsquo;t support complex numbers!
But there is a good reason for that, as explained in the
<a href="https://docs.python.org/2/library/cmath.html"><code>cmath</code> (complex math) library</a>:</p>

<blockquote><p>The reason for having two modules is that some users aren’t interested in
complex numbers, and perhaps don’t even know what they are. They would rather
have <code>math.sqrt(-1)</code> raise an exception than return a complex number.</p></blockquote>

<p></p>
]]></content>
  </entry>
  
</feed>
