<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vim | Erik Ramsgaard Wognsen]]></title>
  <link href="http://blog.erw.dk/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://blog.erw.dk/"/>
  <updated>2022-12-21T23:26:01+01:00</updated>
  <id>http://blog.erw.dk/</id>
  <author>
    <name><![CDATA[Erik Ramsgaard Wognsen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learn Vim the Harder Way, Part II]]></title>
    <link href="http://blog.erw.dk/2016/08/28/learn-vim-the-harder-way-part-ii/"/>
    <updated>2016-08-28T13:29:00+02:00</updated>
    <id>http://blog.erw.dk/2016/08/28/learn-vim-the-harder-way-part-ii</id>
    <content type="html"><![CDATA[<p>In a <a href="/2016/05/16/learn-vim-the-harder-way/">previous post</a> I introduced learning <a href="http://en.wikipedia.org/wiki/Vim_%28text_editor%29">Vim</a> the harder way. To summarize:</p>

<ul>
<li><strong>The easy way</strong>: Use the arrow keys for cursor movement</li>
<li><strong>The hard way</strong>: Don&rsquo;t use arrow keys; use <em>hjkl</em> in <em>normal mode</em></li>
<li><strong>The harder way</strong>: Don&rsquo;t use <em>hjkl</em>; learn Vim&rsquo;s multitude of other motion
commands</li>
</ul>


<p>Now, there&rsquo;s nothing wrong with using the arrow keys per se, but it very often
leads to staying in <em>insert mode</em> most of the time and thus missing out on all
the stuff you can do from <em>normal mode</em>. As someone <a href="http://www.viemu.com/a-why-vi-vim.html">wrote</a> about vi/Vim:</p>

<blockquote><p>your keyboard becomes a huge specialized text-editing gamepad with almost
a hundred buttons.</p></blockquote>

<p>There&rsquo;s nothing wrong with using <em>hjkl</em> either, in fact they&rsquo;re very good
because they force you to use <em>normal mode</em> as your, well, normal mode.
However, normal mode only really provides an advantage if you harness its power
and go beyond the basics. For motions, that involves reducing your use of
<em>hjkl</em>. In this part we see how to do that for inserting and deleting text.</p>

<!-- more -->


<a name="Insert.Without..em.i..em."></a>
<h2>Insert Without <em>i</em></h2>

<p>One of the first things Vim users learn is that you type <em>i</em> to go to insert
mode (where you can write text). Just like <em>hjkl</em>, <em>i</em> is a basic command. And
just like there are many other motions beyond <em>hjkl</em>, there are more commands
that bring you to insert mode:</p>

<ul>
<li><em>a</em> appends text after the current character (like <em>i</em> inserts before it).</li>
<li><em>I</em> and <em>A</em> insert text at the beginning and end of the line, respectively,
no matter where on the line your cursor is.</li>
<li><em>o</em> and <em>O</em> &ldquo;open&rdquo; a new blank line for writing immediately after and before
the current line, respectively (no matter where on the line your cursor is).
When used for programming (for example with <code>:set autoindent</code>), &ldquo;open&rdquo; also
does intelligent indentation.</li>
<li><em>gi</em> inserts text where you last stopped inserting text, no matter where in
the buffer the cursor now is.</li>
</ul>


<p>Try disabling <em>i</em> with <code>:nmap i &lt;nop&gt;</code>, or perhaps with a reminder of what to
do instead: <code>:nnoremap i :echoerr "Try a/I/A/o/O/gi instead!"&lt;cr&gt;</code>. It&rsquo;s really
annoying, but that&rsquo;s the point. Once you have a basic grasp of the other insert
mode commands, you can remove the mapping again with <code>:nunmap i</code>.</p>

<p>By the way, I lied a bit earlier. The command <em>I</em> doesn&rsquo;t insert at the
beginning of the line. It inserts immediately before the first non-whitespace
character of the line, which is often convenient, not least in programming. But
you can still tell Vim to <em>really</em> insert at the beginning of the line with the
command <em>gI</em>. Vim is thorough like that.</p>

<a name="Delete.Without.Backspace"></a>
<h2>Delete Without Backspace</h2>

<p>Now you know a flexible set of commands to go to insert mode. Once you&rsquo;re
there, there&rsquo;s one thing you should not to too much (beside use the arrow
keys), and that is: backspace. Like many other commands, it is a basic
operation good in some cases and inefficient in others. It&rsquo;s good for
correcting a typo, but deleting words and anything bigger is like digging with
a teaspoon. So I&rsquo;d recommend removing the temptation to use the teaspoon by
disallowing backspacing past the position where you started insert mode:</p>

<pre><code>set backspace-=start
</code></pre>

<p>You can still correct typos while you type. In normal mode you can also delete
a few chars with the <em>x</em> and <em>X</em> commands which work like delete and backspace
do in insert mode.</p>

<p>For anything bigger, use the delete command <em>d</em>. It takes a motion or text
object. For example, <code>dw</code> deletes from the cursor position until the start of
the next word, <code>dt'</code> deletes until the next apostrophe, and <code>dap</code> deletes
a paragraph (the one the cursor is currently in). All in one step.</p>

<p>Besides being more efficient, doing it as a single command has the advantage
that it can be undone as a single command (<em>u</em>), and, perhaps more importantly,
that you get the whole thing copied so you can insert it later (in Vim, delete
and cut are the same thing).</p>

<a name="Delete.and.Insert.at.the.Same.Time"></a>
<h2>Delete and Insert at the Same Time</h2>

<p>In the previous section I suggest staying in normal mode when removing text.
But what if you want to both delete <em>and</em> insert text? Just like Vim provides
many commands than combine moving the cursor and inserting text (<em>a</em>, <em>I</em>, <em>A</em>,
etc.), it also provides commands that combine deleting and inserting:</p>

<ul>
<li><em>r</em> replaces the character under the cursor with another character of your
choosing</li>
<li><em>R</em> drops you into replace mode where you overwrite/replace text until you
return to normal mode with Esc.</li>
<li><em>s</em>/<em>S</em> substitute the character/line under the cursor with any text (insert
mode)</li>
<li><em>c</em> changes text into other text: It first awaits your choice of motion or
text object to delete and then drops you into insert mode. For example, <code>c)</code>
changes from the cursor position until the end of the sentence and <code>ci"</code>
changes the whole content of the double quote delimited string the cursor is
in.</li>
<li><em>C</em> changes from the cursor position to the end of the line (similarly to how
<em>D</em> deletes from the cursor position to the EOL while <em>d</em> takes a motion or
text object)</li>
</ul>


<p>If you&rsquo;re comfortable with <em>x</em>/<em>X</em>/<em>d</em>, but not the replace/substitute/change
commands, I&rsquo;d recommend something crazy: Disable <em>x</em>, <em>X</em>, and <em>d</em>:</p>

<pre><code>nmap x &lt;nop&gt;
nmap X &lt;nop&gt;
nmap d &lt;nop&gt;
</code></pre>

<p>Instead, the stuff you want to delete, you can substitute/change into nothing
until the substitute/change commands comes naturally to you.</p>

<p></p>

<a name="Learn"></a>
<h2>Learn</h2>

<p>The point of temporarily disabling commands is not to say they&rsquo;re bad, because
they&rsquo;re not. They are strictly necessary parts of Vim. The point is to <em>also</em>
learn the more powerful and flexible commands. I have only covered the basics
of normal mode, but read <code>:help</code>, <code>:help user-manual</code>, and <a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118">this</a> to
uncover all the cool stuff you can do.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Vim the Harder Way]]></title>
    <link href="http://blog.erw.dk/2016/05/16/learn-vim-the-harder-way/"/>
    <updated>2016-05-16T14:59:23+02:00</updated>
    <id>http://blog.erw.dk/2016/05/16/learn-vim-the-harder-way</id>
    <content type="html"><![CDATA[<p>The first lesson of the official <a href="http://en.wikipedia.org/wiki/Vim_%28text_editor%29">Vim</a> tutorial (&ldquo;vimtutor&rdquo;) introduces
the navigation keys <em>h</em>, <em>j</em>, <em>k</em>, <em>l</em>. This is where the user might go
&ldquo;What?&rdquo;, followed perhaps by &ldquo;What&rsquo;s wrong with the arrow keys?&rdquo; The tutorial
has this answer: &ldquo;The cursor keys should also work. But using hjkl you will be
able to move around much faster, once you get used to it. Really!&rdquo;</p>

<p><img class="center" src="/images/posts/vimtutor.png"></p>

<p>From here, I think most people continue using Vim with the arrow keys and
perhaps mouse because that&rsquo;s what they&rsquo;re used to, and why change something
that works? Users who actually use hjkl from this point onwards (either by
sheer willpower or by disabling the mouse and arrow keys) are learning Vim &ldquo;the
hard way&rdquo;.</p>

<p>Let me say from the beginning that I agree with the tutorial: Using hjkl <em>is</em>
better. But for most people the hard way is not the right way. Learning Vim
<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">progressively</a> is more fun and will allow you to switch to Vim
while still <a href="http://yehudakatz.com/2010/07/29/everyone-who-tried-to-convince-me-to-use-vim-was-wrong/">getting work done</a>. In addition to the official
vimtutor, you can also try an <a href="http://www.openvim.com/tutorial.html">interactive tutorial</a>, or even an
<a href="http://vim-adventures.com/">adventure game</a>.</p>

<p>If, however, you are going for the hard way, let me propose learning Vim the
<em>harder</em> way!</p>

<!-- more -->


<a name="Learning.Vim.the.Harder.Way"></a>
<h2>Learning Vim the Harder Way</h2>

<p>The harder way is to use neither arrow keys <em>nor</em> hjkl.</p>

<p></p>

<p>So what do you do instead? Finding out is exactly the point of this exercise.
Vim has a very rich set of motion commands (see <code>:help motion.txt</code> in Vim or
<a href="https://raw.githubusercontent.com/vim/vim/master/runtime/doc/motion.txt">here</a>) that you might never come across if you can get by with hjkl
&mdash; just like you wouldn&rsquo;t learn hjkl if you kept using the arrow keys.</p>

<p>While writing this article, I experimented with various variations on this.
After disabling hjkl, it took some time before I noticed that the sideways
motions <em>h</em> and <em>l</em> were missing (i.e., I use other, more direct motions more).
On the other hand, the up-down motions <em>j</em> and <em>k</em> in many cases <em>are</em> the most
efficient motions when combined with counts (see <code>:help count</code>) and relative
line numbers. Therefore, I do not recommend disabling <em>j</em> and
<em>k</em> completely. But to nudge you into using them intelligently, I suggest
disabling the &ldquo;repeat keys&rdquo; feature in your OS keyboard settings:</p>

<p><img class="center" src="/images/posts/repeat_keys.png"></p>

<p>When this is done, disable the mouse and <em>h</em> and <em>l</em> as well as the arrow keys
in both normal mode and insert mode:</p>

<pre><code class="html">set nocompatible
set mouse=
map h &lt;nop&gt;
map l &lt;nop&gt;
map &lt;left&gt; &lt;nop&gt;
map &lt;down&gt; &lt;nop&gt;
map &lt;up&gt; &lt;nop&gt;
map &lt;right&gt; &lt;nop&gt;
imap &lt;left&gt; &lt;nop&gt;
imap &lt;down&gt; &lt;nop&gt;
imap &lt;up&gt; &lt;nop&gt;
imap &lt;right&gt; &lt;nop&gt;
</code></pre>

<p>The first command, <code>set nocompatible</code>, changes many options from vi compatible
to sane.</p>

<p>You can try these commands in Vim by typing &lsquo;:&rsquo; to go command line mode, typing
the command, and then pressing Enter. For example: <code>:map h &lt;nop&gt;</code> followed by
Enter. This lasts until you close Vim or undo it with <code>:unmap h</code>. To make it
stick, put the commands in your vimrc configuration file (see <code>:help vimrc</code>),
and they will be loaded each time you start Vim, until you remove them from
your vimrc again.</p>

<a name="Start.Learning"></a>
<h2>Start Learning</h2>

<p>At first, the above settings are a pain in the gluteus maximus.</p>

<p>Fire up <a href="https://raw.githubusercontent.com/vim/vim/master/runtime/doc/motion.txt"><code>:help motion.txt</code></a> and look around. (If you&rsquo;re tired of
moving down one <em>j</em> at a time, use CTRL-f and CTRL-b to go forward and backward
one page at a time. Or put the cursor on a <code>|keyword|</code> and press CTRL-] to jump
to that subject.)</p>

<p>To use <em>j</em> and <em>k</em> efficiently for editing, enable relative line numbers:</p>

<pre><code>set number
set relativenumber
</code></pre>

<p>They look like this:</p>

<p><img class="center" src="/images/posts/vim_relativenumber.png"></p>

<p>As shown in the margin, the cursor is on line 124. To go to the line &ldquo;To
use&hellip;&rdquo;, just look to the left, read the 9, and go nine lines up with <em>9k</em>.
Without relative line numbers (i.e. <code>:set norelativenumber</code>, or <code>:set nornu</code>
for short), you could also see that this line is line 115 and go to it with
<em>115G</em>, but that&rsquo;s twice the typing.</p>

<p>While getting by with <em>j</em> and <em>k</em>, missing <em>h</em> and <em>l</em> is probably really bad
at first. Take a look at <code>:help word-motions</code> and <code>:help left-right-motions</code>
(which are sections of motion.txt). The six motions <em>f</em>, <em>F</em>, <em>t</em>, <em>T</em>,
<em>(comma)</em>, and <em>;</em> (where <em>(comma)</em> is the comma key itself), will come in
especially handy. To give an example, with the cursor at X on this line and an
&lsquo;x&rsquo; somewhere later, typing <em>fx</em> will go to that x. (Go try it in Vim!) For
letters more common than x, these find commands are less useful. But uppercase
letters and punctuation are easy targets, and help you navigate very quickly.</p>

<p>Playing around with <em>f</em> and family, you will notice that while they are very
fast to type, they only move within the current line, and of course they only
find one symbol at a time. Read <code>:help search-commands</code> to get into the big
league search commands.</p>

<p>At this point I&rsquo;ll remark that the search default settings are a bit lame.
I prefer these settings regarding search:</p>

<pre><code class="vim">set incsearch   " Search while you type
set hlsearch    " Highlight all matches
set ignorecase  " Ignore case while searching...
set smartcase   " ...unless you use uppercase letters in the search pattern.
</code></pre>

<p>Especially search <span style="background-color: yellow;">highlight</span> can
be useful, but after finding what you were looking for, you might want to get
rid of the <span style="background-color: yellow;">highlight</span>ing. Rather
than disabling it completely (<code>:set nohlsearch</code>), just turn it off until your
next search with <code>:nohlsearch</code>, or <code>:noh</code> for short.</p>

<p>In addition, when there are many highlighted matches close to each other,
Damian Conway&rsquo;s <a href="https://github.com/thoughtstream/Damian-Conway-s-Vim-Setup/blob/master/plugin/hlnext.vim">hlnext</a> plugin helps you see where you&rsquo;re at by
blinking the next hit reached with <em>n</em> or <em>N</em>.</p>

<p></p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>As I mentioned in the beginning, learning Vim incrementally is the most useful.
So the harder way is not the best for most beginners. But I think it is very
useful for people who use Vim frequently but would like to unlock more of its
potential.</p>

<p>Also, we have just scratched the surface of what you can do in Vim. For any
learner, new or experienced, I&rsquo;d recommend reading <code>:help user-manual</code> from
start to end. This is in fact how I learned Vim.</p>

<p>Update: See also <a href="/2016/08/28/learn-vim-the-harder-way-part-ii/">part II</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Entering Dates and Times in Vim]]></title>
    <link href="http://blog.erw.dk/2016/04/19/entering-dates-and-times-in-vim/"/>
    <updated>2016-04-19T07:55:20+02:00</updated>
    <id>http://blog.erw.dk/2016/04/19/entering-dates-and-times-in-vim</id>
    <content type="html"><![CDATA[<p></p>

<p>As a young Windows user, I learned that if you write <code>.LOG</code> as the first line
of a text file, then each time you open it in Notepad, it appends the current
time and date to the file. That was pretty cool. And useful for logging things,
as <code>.LOG</code> implies. Later I became a <a href="http://www.vim.org/about.php">Vim</a> user and started enjoying all
the customization I can do to my editor. Or perhaps I became a Vim user because
I enjoy customizing! Either way, I like my date and time shortcuts in Vim. For
example:</p>

<pre><code class="C">noremap! &lt;expr&gt; ,t strftime("%H:%M")
</code></pre>

<p>This means: Map the key sequence <code>,t</code> (comma followed by &rsquo;t&#8217;) to the result of
the expression <code>strftime("%H:%M")</code> in the insert and command line modes. So if
I write &ldquo;The package arrived ,t&rdquo;, what I will see is &ldquo;The package arrived
13:43&rdquo;, or whatever the time was. I use capital T for further precision
(seconds), <code>,d</code> to insert the date (of course in ISO 8601 format), and <code>,l</code> to
insert date and time together (&lsquo;l&rsquo; for log, as with <code>.LOG</code>):</p>

<pre><code class="C">noremap! &lt;expr&gt; ,T strftime("%H:%M:%S")
noremap! &lt;expr&gt; ,d strftime("%Y-%m-%d")
noremap! &lt;expr&gt; ,l strftime("%Y-%m-%d %H:%M")
</code></pre>

<!-- more -->


<p>There are only so many shortcuts you can make with the Control and Alt keys,
but if you use key sequences, you have many more. I have chosen comma as
a &ldquo;leader&rdquo; key because I rarely write it without following it by a space. In
case I do want to write literally &ldquo;,t&rdquo; without a space, I have to type &ldquo;,,t&rdquo;,
where the double comma is a command to insert a single comma:</p>

<pre><code class="C">noremap! ,, ,
</code></pre>

<p>The &ldquo;nore&rdquo; part of &ldquo;noremap&rdquo; means &ldquo;no remapping&rdquo;, i.e., don&rsquo;t use the output
of this mapping as input to another mapping. If it <em>did</em> remap, the one comma
produced here would be interpreted as the start of one of the mappings starting
with comma, including itself.</p>

<p></p>

<p>I use these functions daily, for example at work, where I keep a log of which
tasks I start when. I also use it a lot with <a href="http://todotxt.com/">todotxt</a> when writing
due dates or threshold dates. Finally, I added a mapping to insert the first of
the next month.</p>

<pre><code class="C">noremap! &lt;expr&gt; ,D
            \ strftime("%Y") + strftime("%m") / 12 . "-" .
            \ repeat('0', 2-len((strftime("%m") + 1) % 12)) .
            \ (strftime("%m") + 1) % 12 .
            \ "-01"
</code></pre>

<p>Typing &ldquo;,D&rdquo; today would yield 2016-05-01, for example.</p>

<p>Entered times and dates can also be manipulated with Vim&rsquo;s Ctrl-A and Ctrl-X
increment and decrement commands. Want to add two weeks? Type 14 followed by
Ctrl-X to add 14 days.</p>

<p>My duplicate increment line mappings also come in handy:</p>

<pre><code class="C">nnoremap &lt;silent&gt;       &lt;F2&gt;  @='yyp&lt;c-v&gt;&lt;c-a&gt;'&lt;cr&gt;
nnoremap &lt;silent&gt;       &lt;F3&gt;  @='yypE&lt;c-v&gt;&lt;c-x&gt;'&lt;cr&gt;
</code></pre>

<p>If I write &ldquo;2016-04-20 Plan:&rdquo; followed by 10 and then the F3 key, I immediately
have:</p>

<pre><code>2016-04-20 Plan:
2016-04-21 Plan:
2016-04-22 Plan:
2016-04-23 Plan:
2016-04-24 Plan:
2016-04-25 Plan:
2016-04-26 Plan:
2016-04-27 Plan:
2016-04-28 Plan:
2016-04-29 Plan:
2016-04-30 Plan:
</code></pre>

<p>Actually, Vim just thinks it&rsquo;s decrementing the integer -19 to -20 and so on,
but Tim Pope&rsquo;s <a href="https://github.com/tpope/vim-speeddating">speeddating.vim</a> plugin adds date and time
awareness, so typing Ctrl-A on 2016-04-30 would result in 2016-05-01 and not
2016-04-31. Happy Vimming!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Language of vi, Improved]]></title>
    <link href="http://blog.erw.dk/2014/11/25/the-language-of-vi-improved/"/>
    <updated>2014-11-25T02:50:20+01:00</updated>
    <id>http://blog.erw.dk/2014/11/25/the-language-of-vi-improved</id>
    <content type="html"><![CDATA[<p>In <a href="/2014/10/31/the-essence-of-vi/">a previous post</a> I described the &ldquo;language&rdquo; metaphor of the text
editor <a href="http://en.wikipedia.org/wiki/Vi">vi</a>. To recap,</p>

<ul>
<li>Verbs are commands such as change <code>c</code>, delete <code>d</code>, yank <code>y</code>, and put <code>p</code></li>
<li>Nouns (text objects): a paragraph <code>ap</code>, a string <code>a"</code>, etc.</li>
<li>Prepositional phrases (motions):
&ldquo;to the next word&rdquo; <code>w</code>,
&ldquo;to the next regex&rdquo; <code>/</code></li>
<li>Numerals (counts) as seen in
&ldquo;indent ten lines&rdquo; <code>10&gt;&gt;</code> and
&ldquo;to the 27th line&rdquo; <code>27gg</code>.</li>
</ul>


<p>This time around, we&rsquo;ll see how <a href="http://www.vim.org/about.php">Vim</a> (vi improved) adds a new word order
to make you speak more clearly, and <em>meta-verbs</em> to blow your mind!</p>

<!-- more -->


<p></p>

<a name="Speak.Before.You.Think"></a>
<h2>Speak Before You Think</h2>

<p>Near the end of my previous post we got to the numerals, or counts as they&rsquo;re
officially called. Counts are useful, especially when large numbers are
involved, but sometimes it pays off to use Vim without thinking too much ahead.
Just start speaking:</p>

<blockquote><p>Delete &hellip; a bit more &hellip; a bit more &hellip; bit more &hellip; ok, stop.</p></blockquote>

<p>While this is the way many people delete text on their computer, Vim makes it
a lot more efficient than the typical awkward bursts of holding down the delete
key until you delete enough (and probably too much). For example, <code>dw....</code>
deletes one word, then the next, and so on, five in total. (Remember,<code>dw</code>
deletes one word, and the dot <code>.</code> command repeats this action.) This can be
faster than the equivalent <code>d5w</code> because you don&rsquo;t need to count the words
before you start deleting . The running feedback you get by seeing the words
disappear one by one is very helpful and avoids the mistakes that could have
happened due to miscounting. It is especially useful for objects that vary
considerably in size (sentences, paragraphs), because they are harder to count
quickly.</p>

<p>But this approach doesn&rsquo;t work for common operations such as change <code>c</code> or yank
<code>y</code>. When you yank (copy), you most likely want all the text in the clipboard
at the same time; not one word replacing the next until you are left with only
the last word in the clipboard. Probably for the same reason, the repeat <code>.</code>
command doesn&rsquo;t consider yanking a repeatable action. (By the way, I say &lsquo;the
clipboard&rsquo; because it is a familiar term to many, but in Vim, they&rsquo;re called
registers, and there&rsquo;s a whole lot more than one of them!) Instead of repeat,
we can use <em>visual mode</em>, which gives both pleasant feedback and works with all
actions.</p>

<p></p>

<p></p>

<a name="L....or.Speak.Like.Yoda"></a>
<h2>&hellip; or Speak Like Yoda</h2>

<p><span class='caption-wrapper'><img class='caption' src='http://upload.wikimedia.org/wikipedia/commons/4/49/Teletype-Fernschreiber_T100_Siemens.jpg">http://upload.wikimedia.org/wikipedia/commons/4/49/Teletype-Fernschreiber_T100_Siemens.jpg</a>&#8217; width=&#8217;382&#8217; height=&#8217;346&#8217; alt=&#8217;<a href="http://commons.wikimedia.org/wiki/File:Teletype-Fernschreiber_T100_Siemens.jpg#mediaviewer/File:Teletype-Fernschreiber_T100_Siemens.jpg">Fernschreiber Modell T100</a> by <a href="http://de.wikipedia.org/wiki/User:Nightflyer">Nightflyer</a> / <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a>&#8217;><span class='caption-text'><a href="http://commons.wikimedia.org/wiki/File:Teletype-Fernschreiber_T100_Siemens.jpg#mediaviewer/File:Teletype-Fernschreiber_T100_Siemens.jpg">Fernschreiber Modell T100</a> by <a href="http://de.wikipedia.org/wiki/User:Nightflyer">Nightflyer</a> / <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a></span></span>
</p>

<p>To explain visual mode, we will first pay the 1970s
a brief visit.  In vi, &ldquo;visual mode&rdquo; was a mode that was &ldquo;more visual&rdquo; than the
<a href="http://en.wikipedia.org/wiki/Teleprinter">Teletype</a> oriented editors vi
superseded and subsumed
(<a href="http://en.wikipedia.org/wiki/Ed_%28text_editor%29">ed</a> and
<a href="http://en.wikipedia.org/wiki/Ex_%28text_editor%29">ex</a>, respectively).  It
meant simply that you could see the file <em>while you edited it</em>.  However, this
form of visual feedback was soon considered normal.  Case in point, vi&rsquo;s visual
mode is Vim&rsquo;s normal mode.</p>

<p></p>

<p>The way to be more visual than Vim&rsquo;s normal mode is to highlight the text that
will be changed before the change is executed. This is similar to selecting
text in mainstream editors with the mouse or by using the arrow keys with the
shift key held down. In these, typing while text is selected replaces the
selected text with the typed text. Vim&rsquo;s visual mode however retains the
keyboard&rsquo;s &ldquo;gamepad role&rdquo; (see <a href="/2014/10/31/the-essence-of-vi/">my previous post</a>). (Vim also has
a &ldquo;mainstream&rdquo; <em>select mode</em> but it is mainly used to imitate
<strike>lesser</strike> other editors.)</p>

<p>You enter visual mode using <code>v</code>, then use text objects and motions to highlight
the text you want to affect. This reverses the word order in the vi language,
effectively making you command Vim like Yoda:  &ldquo;These lines delete (you must!)&rdquo;
Compare:</p>

<ul>
<li><code>das</code>: &ldquo;Delete a sentence.&rdquo;</li>
<li><code>vasd</code>: &ldquo;A sentence delete.&rdquo;</li>
<li><code>dasdw</code>: &ldquo;Delete a sentence. Delete the next word.&rdquo;</li>
<li><code>vased</code>: &ldquo;A sentence and the next word delete.&rdquo;</li>
</ul>


<p></p>

<p></li>
</ul>


<p>So, visual mode is nice because it gives visual feedback on the area you are
going to operate on before you commit to it and type the operator. But it
doesn&rsquo;t stop there.</p>

<p></p>

<a name="Visual.Basics"></a>
<h2>Visual Basics</h2>

<p>What would you do if you had a lot of gamepad real estate to go along with
visual mode?</p>

<p>First of all, visual mode actually comes in three flavors: Character <code>v</code>, line
<code>V</code>, and block <code>&lt;c-v&gt;</code>. Here I switch around between them a bit:</p>

<p>
<video controls>
<source src='http://blog.erw.dk/videos/posts/vimvisual.webm' type='video/webm; codecs=vp8' />
</video></p>

<p>(The numbers in the margin show the line number for the line the
cursor is on, and the distance to the other lines. This <a href="http://vimdoc.sourceforge.net/htmldoc/options.html#%27relativenumber%27">feature</a> makes is easy to use counts with line-based operators.)</p>

<p>Visual character mode is the one you will find most familiar: The selection
starts somewhere, continues along the direction of the text, wraps at the ends
of lines, and ends somewhere. In visual <em>line</em> mode, every whole line from the
one the selection starts in to the one it ends in, is selected. This makes it
easy to select whole lines without moving the cursor to the start and end of
a line. Especially useful in programming, where line is often synonymous with
<em>statement</em>. Finally, visual block mode selects a rectangle of text. Applying
operators to blocks is very powerful and enables things that would take a long
time without block mode.</p>

<p></p>

<p><video class='right' controls>
<source src='http://blog.erw.dk/videos/posts/vimblock.webm' type='video/webm; codecs=vp8' />
</video></p>

<p>Block mode can also be used to insert text at several lines simultaneously.
From block mode, insert <code>I</code> and append <code>A</code> start insert mode, and when the
insertion is done, that text is then inserted in every line along the left or
right edge of the block, respectively.
Also, the <code>$</code> motion can be used to extend the selection to the ends of
lines. If the lines have different lengths, the result is a jagged block.
Appending <code>A</code> to this inserts text at the end of each line, wherever the end of
that line is. In the video I demonstrate both <code>I</code> and <code>A</code>. Here&rsquo;s a breakdown:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;c-v&gt;</span>jj$Ifoo(<span class="nt">&lt;esc&gt;</span>gvA)<span class="nt">&lt;esc&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;p&gt;&lt;c-v&gt;</span>                         Ctrl-v to start visual block mode
</span><span class='line'>     jj$                      Move cursor two down and to the end of line
</span><span class='line'>        I                     Start block insert mode
</span><span class='line'>         foo(                 Write <span class="ni">&amp;ldquo;</span>foo(<span class="ni">&amp;rdquo;</span>
</span><span class='line'>             <span class="nt">&lt;esc&gt;</span>            Escape to normal mode (completes the other lines)
</span><span class='line'>                  gv          Start visual mode with previous selection
</span><span class='line'>                    A         Start appending in block insert mode
</span><span class='line'>                     )<span class="nt">&lt;esc&gt;</span>   Write <span class="ni">&amp;ldquo;</span>)<span class="ni">&amp;rdquo;</span> and escape to normal mode
</span></code></pre></td></tr></table></div></figure></p>

<p></p>

<p>All this might look scary, but that&rsquo;s of course part of what makes it so cool!</p>

<p>In the end of the video I do the same thing in one step using Tim Pope&rsquo;s
<a href="https://github.com/tpope/vim-surround">surround.vim</a> plugin. With the same selection active, I use
<code>Sf</code> to &ldquo;surround with function-call&rdquo;, type &ldquo;foo&rdquo; and enter.</p>

<a name="Neat.Tricks"></a>
<h3>Neat Tricks</h3>

<p>Have you tried selecting text in a mainstream editor and finding out you
started the selection in the wrong place? So you do the selection again, and do
it right this time. Well, Vim is all about efficiency: In visual mode, <code>o</code>
moves the cursor to the other end of the selection, so you can adjust it
without starting over. As amazing as it is simple! A soft, smiling kitten is
born every time you use this feature.</p>

<p></p>

<p>Also, with visual mode, you can crawl up the DOM tree: <code>at</code> extends the
selection to the enclosing tag-block (Vim-speak for an HTML/XML element).
Applied repeatedly, a bigger and bigger block of markup is selected,
corresponding to nodes further up the DOM tree.</p>

<p></p>

<p>Both visual mode and repeat <code>.</code> can be used in the &ldquo;speak before you think&rdquo;
manner, but visual mode works with all operators. It also has another advantage
over repeat: The operation is &ldquo;committed&rdquo; in one step, so it can be <em>undone</em> in
one step. This brings us to &hellip;</p>

<a name="Meta-Verbs"></a>
<h2>Meta-Verbs</h2>

<p><em>Undo</em> is a verb. It&rsquo;s a verb for a command that reverts the latest change, no
surprises there. But what happens when you undo two times in a row?</p>

<p>In vi, undo is a change like any other. Thus, if the latest change is an undo,
undo will revert that undo action. In other words, typing <code>uu</code> is a no-op! Vim,
being &ldquo;vi improved&rdquo;, can <a href="http://vimdoc.sourceforge.net/htmldoc/undo.html#undo-two-ways">emulate vi</a> or use its own improved undo,
which could be called a <em>meta-verb</em>: Verbs change text, but meta-verbs change
changes. So undo <code>u</code> and redo <code>&lt;c-r&gt;</code> go back and forth in the change history,
as is common in most modern programs.  But there&rsquo;s more:</p>

<p>Let&rsquo;s say you are writing a blog post.  Well into the process you remember an
earlier phrasing that you changed, but now you want it back.  You take numerous
steps back in history (perhaps employing a count: <code>25u</code>) until you find it. You
copy it, and you&rsquo;re ready to continue.  But before you remember that you should
redo to return to the newest version of the document, you make a new change.
If you used a simpler editor that version would now be lost forever.</p>

<p></p>

<p>Vim knows that undo/redo is not a linear history, it is a tree. Normal,
sequential changes extend a single branch of the tree. But when you go back and
make a new change as in the example above, that change sprouts another
branch. Vim <a href="http://vimdoc.sourceforge.net/htmldoc/usr_32.html">stores this tree</a> and let&rsquo;s you recover your work.</p>

<p><video class='right' controls>
<source src='http://blog.erw.dk/videos/posts/vimundotree.webm' type='video/webm; codecs=vp8' />
</video>
</p>

<p>In this video, I demonstrate the undo tree with all changes being adding small
bits of text, and the layout of the text representing the branches of the tree.
Undo <code>u</code> and redo <code>&lt;c-r&gt;</code> always go up and down the current branch (in this
video literally up and down). The commands <code>g-</code> and <code>g+</code> go through older and
newer <em>changes</em> to the text, which can be spread around the tree. I go
backwards with <code>g-</code> (watch for the &lsquo;g&rsquo; in the lower right corner) through the
events of entering &ldquo;six&rdquo; and &ldquo;five&rdquo; to the state after entering &ldquo;four&rdquo;, which
is in the original branch, before undoing &ldquo;three&rdquo; and &ldquo;four&rdquo;. Using <code>g+</code> brings
me forward again to the changes in the new branch.</p>

<p>Because all changes are ordered chronologically (no matter the undos and redos
done between them and the sprouting of new branches), they can be accessed
in a linear history with <code>g-</code> and <code>g+</code>. You can even travel in time explicitly:
<code>:earlier 3m</code> (minutes), <code>:later 2h</code> (hours). But in practice all you might
need is a few <code>g-</code>es once in a blue moon.</p>

<p></p>

<p>On top of that we have <a href="http://vimdoc.sourceforge.net/htmldoc/undo.html#undo-persistence">persistent undo</a> between sessions, which
I think makes Vim&rsquo;s undo the most powerful undo functionality I have seen in
a program. If you know of any contenders, please leave a comment!</p>

<p></p>

<p>Vim itself never actually shows you the tree directly, but <a href="http://stevelosh.com/">Steve Losh</a>&rsquo;s
graphical undo a.k.a. <a href="http://sjl.bitbucket.org/gundo.vim/">Gundo</a> plugin looks nice for that purpose
(<a href="http://www.screenr.com/M9l">screencast here</a>).</p>

<p>Now you have seen two powerful features that are in Vim but not vi: visual mode
and the undo system. Here&rsquo;s one more before we end:</p>

<a name="Record.and.Replay.Changes"></a>
<h3>Record and Replay Changes</h3>

<p></p>

<p>Another meta-verb is <em>record</em> <code>q</code> &mdash; it doesn&rsquo;t change the text by itself, but
it records the use of other verbs. The recording can then be played back by
(regular verb) <em>execute</em> <code>@</code> to use the same changes in a new context.</p>

<p>The xkcd forums user EvanED once <a href="http://forums.xkcd.com/viewtopic.php?f=40&amp;t=15855#p577619">demonstrated</a> how he used emacs to
efficiently</p>

<pre><code class="C">// turn this ...
void stateDoOperation1(state* state, int param1);
int stateDoOperation2(state* state, int param1);
int stateDoOperation3(state* state, int param1, double param2);

// ... into this:
doOperation1(int param1);
doOperation2(int param1);
doOperation3(int param1, double param2);
</code></pre>

<p>I <a href="http://en.wikipedia.org/wiki/Editor_war">defended the honor</a> of Vim with this salvo:</p>

<pre><code class="html">    qqdfe~fsdf,x&lt;enter&gt;q2@q

    qq                        start recording to register 'q'
      dfe                     delete to next 'e' (the end of "state")
         ~                    invert case of letter under cursor (the 'D' in "Do")
          fs                  move cursor to next 's' (the beginning of "state")
            df,               delete to next ','
               x              delete (the space after the ',')
                &lt;enter&gt;       move to beginning of next line
                       q      stop recording
                        2@q   replay 'q' two times
</code></pre>

<p>Here I will do the same using visual mode so you can better see what&rsquo;s going
on:</p>

<p><video controls>
<source src='http://blog.erw.dk/videos/posts/vimmacro.webm' type='video/webm; codecs=vp8' />
</video></p>

<p>He and I parted ways amicably! As he said</p>

<blockquote><p>vi does seem faster in the hands of someone who&rsquo;s skilled. But it also seems
that emacs is faster in the hands of someone who isn&rsquo;t particularly skilled</p></blockquote>

<p>And that&rsquo;s probably true!</p>

<p></p>

<p></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Essence of vi]]></title>
    <link href="http://blog.erw.dk/2014/10/31/the-essence-of-vi/"/>
    <updated>2014-10-31T09:49:46+01:00</updated>
    <id>http://blog.erw.dk/2014/10/31/the-essence-of-vi</id>
    <content type="html"><![CDATA[<p></p>

<p><a href="http://www.vim.org/about.php">Vim</a> is a popular and widely distributed text editor improving on the
legendary <a href="http://en.wikipedia.org/wiki/Vi">vi</a> from the late 1970s.  If you are reading this on Mac or
Linux, chances are that Vim is already installed on your computer, included
with your OS.  If you tried Vim and found it too strange to use, or if you use
it but still harbor the idea that it was made by (or for!) aliens, you&rsquo;ve come
to the right place!</p>

<p></p>

<p>Vim is a very powerful tool, but often misunderstood.  There are plenty of
tutorials that go through the basics, but they usually fail to paint the big
picture.  <em>Why</em> the weird keyboard shortcuts, and the modes?  Why is it
worthwhile to learn?  In this post I will try to answer these questions.  And
I am pleased to say that the answer doesn&rsquo;t start with <em>h</em>, <em>j</em>, <em>k</em>, <em>l</em>, or
<em>i</em>.</p>

<p>Instead of the traditional bottom-up tutorial, this will be a top-down
introduction, that uncovers the <em>essence of vi</em> and the almost poetic language
you use to speak to Vim and vi.  It is my hope that reading it will make your
time with Vim both more useful and more enjoyable.  I have myself enjoyed Vim
since 2007, and I also <a href="https://github.com/vim/vim/blob/master/runtime/syntax/asm.vim">contribute a tiny bit</a> to it.</p>

<p></p>

<!-- more -->




<div id="toc">
<ul>
 <li>
 <ul>
  <li><a href="#Don.t.Worry.About.Modes">Don&#8217;t Worry About Modes</a></li>
  <li><a href="#Play.with.the.Gamepad">Play with the Gamepad</a></li>
  <li><a href="#The.Language.of.vi">The Language of vi</a>
  <ul>
   <li><a href="#Verbs">Verbs</a></li>
   <li><a href="#Nouns.Objects">Nouns/Objects</a></li>
   <li><a href="#Prepositional.Phrases.Motions">Prepositional Phrases/Motions</a></li>
   <li><a href="#Numerals">Numerals</a></li>
  </ul>
  </li>
  <li><a href="#Expand.your.Vocabulary">Expand your Vocabulary</a></li>
  <li><a href="#Vim.vs..vi">Vim vs. vi</a></li>
  <li><a href="#Real.Keyboard.Shortcuts">Real Keyboard Shortcuts</a></li>
  <li><a href="#What.about.Usability.">What about Usability?</a></li>
  <li><a href="#Conclusion">Conclusion</a></li>
  <li><a href="#Afterword">Afterword</a></li>
 </ul>
 </li>
</ul>


</div>


<a name="Don.t.Worry.About.Modes"></a>
<h2>Don&rsquo;t Worry About Modes</h2>

<p>In Adobe Photoshop, pressing <code>L</code> selects the lasso tool, and <code>M</code> the marquee
tool.  Photoshop has many tools and functions, and there are many letters on
the keyboard &mdash; good.  But for most writing applications and text editors, the
letter keys are used for typing.  In these programs (and Photoshop), keyboard
shortcuts use modifiers, for example <code>ctrl-s</code> to save changes.  This means that
prime keyboard real estate is not used to its fullest.  50+ easy-to-press
shortcuts &mdash; upper and lower case letters &mdash; are only used for a single
purpose.</p>

<p></p>

<p>A different approach to text editing is <em>modal editing</em>.  Here the &ldquo;typing
mode&rdquo; is just one of several modes of using the editor (and thus the keyboard).
It is distinct from the mode(s) wherein you move the cursor, copy, paste, etc.
Notably, it often makes sense that the typing mode, or insert mode as it is
commonly called, is <em>not the default mode</em>.  The reason is that it is far more
common to edit, write, and program incrementally, than it is to write a piece
from start to finish.  You navigate around the text to read, think, make small
adjustments, and enter a few words, sentences, or statements at a time.</p>

<p>Vim has many modes, with <em>normal</em> (&ldquo;command&rdquo;) mode and <em>insert</em> mode being the
two main modes.  Now, I could enumerate all the modes, their roles, and how to
switch between them, but I&rsquo;m not going to.  Because when you use Vim naturally,
you don&rsquo;t think about modes, you think about <em>actions</em>.  And the actions lead
you naturally to the mode changes.  Think about finding content on a web page
in your browser: You press <code>ctrl-f</code> which opens a text field.  Here you write
your search string, press <code>&lt;enter&gt;</code> a few times, then <code>&lt;esc&gt;</code> when you&rsquo;re done.
You just used FIND MODE!  (It was super effective!)</p>

<p></p>

<p>Modal editing simply gives you more buttons for actions.  As
<a href="http://www.viemu.com/a-why-vi-vim.html">Jon Beltran de Heredia wrote</a>:</p>

<blockquote><p>with vi, your keyboard becomes a huge specialized text-editing gamepad with
almost a hundred buttons.</p></blockquote>

<a name="Play.with.the.Gamepad"></a>
<h2>Play with the Gamepad</h2>

<p>It can be hard to separate what you usually do with a text editor from what you
want to do with <em>the text</em>.  Learning Vim, you might ask &ldquo;How do I select all
text?&rdquo; After all, in most editors, this is a simple <code>&lt;c-a&gt;</code> (this is another
way of writing <code>ctrl-a</code>).  I could tell you how to do it in Vim (one way is
<code>ggVG</code>), but it is not in the spirit of vi.  In fact, it&rsquo;s not even possible in
vi.  And <em>to master Vim, you must understand vi</em>.  (In a later post I will
cover some &ldquo;philosophical&rdquo; differences between Vim and vi. <em>Update 2014-11-25:
<a href="/2014/11/25/the-language-of-vi-improved/">Here it is!</a></em>) Instead, realize that
selecting text is a means, but to what end?  <em>Why</em> do you want to select all?</p>

<p>Do you want to copy everything?  Then copy, don&rsquo;t select.  It&rsquo;s &ldquo;<code>ggyG</code>&rdquo;. Type
it one letter at a time, and pay attention to case.  What does it mean?  The
<code>gg</code> part moves the cursor to the first line, <code>y</code> then <em>yanks</em> (copies) every
line until (and including) <code>G</code>, the last line.  vi is older than the
standardized cut, copy, and paste, hence the name &ldquo;yank&rdquo;.</p>

<p></p>

<p>Now, if you would think <code>ggyG</code> is no faster than <code>&lt;c-a&gt;&lt;c-c&gt;</code> (select all,
copy) in a regular editor, you&rsquo;d be right.  But say you wanted to copy just
a paragraph?  Type <code>yap</code> to &ldquo;yank a paragraph&rdquo;, with the cursor anywhere in
that paragraph.  Or copy an HTML/XML element? Go ahead and &ldquo;yank a tag-block&rdquo;,
<code>yat</code>.  Then <em>put</em> (paste) three copies of it: <code>3P</code>.  And change the content
(of whichever one you put the cursor on): <code>cit</code> (&ldquo;change inner tag-block&rdquo;).</p>

<p>This last command is slightly different from the others.  It deletes the
content of the element, then drops you to insert mode with the cursor inside
the element, i.e. <code>&lt;foo bar="baz"&gt;</code>between the tags<code>&lt;/foo&gt;</code>.  Then you type
your new content, followed by <code>&lt;esc&gt;</code>, which returns you to normal mode,
simultaneously completing the action.  It might go like this, from start to
finish:  <code>citMy new content&lt;esc&gt;</code>.</p>

<p>Then move to another element and type <code>.</code> to repeat the action!</p>

<p>In
<a href="https://jeetblogs.org/post/grokking-the-zen-of-the-vim-wu-wei/">the words of Jeet Sukumaran</a>:</p>

<blockquote><p>It seemed that, without my hands leaving the keyboard, just a few strokes
here and a few taps there, I was capable of dancing all over the document,
and perform everything from extremely precise [targeted] micro-surgery to
massive document-wide renovations.</p></blockquote>

<a name="The.Language.of.vi"></a>
<h2>The Language of vi</h2>

<p>Mode changes take time to get accustomed to.  They are very visible and
&ldquo;demanding&rdquo; the first many times you use a modal editor.  Hence, they get a lot
of attention.  But too often they steal the attention from the more important
concept of actions.</p>

<p><a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118#1220118">People</a>
<a href="http://yanpritzker.com/2011/12/16/learn-to-speak-vim-verbs-nouns-and-modifiers/">have</a>
<a href="http://stevelosh.com/blog/2010/09/coming-home-to-vim/#a-language-of-text-editing">described</a>
Vim/vi as having a language of editing.  Perhaps you already got the feeling
from the mnemonics above such as &ldquo;yank a paragraph&rdquo;.  The language of vi is how
you instruct the editor to perform actions.  One action is one sentence, and
a sentence consists of verbs, nouns, etc.  Here I will pursue the idea with
a bit more systematically than the aforementioned sources.</p>

<p>There are four possible sentences types/word orders:</p>

<ul>
<li>Verb</li>
<li>Verb Object</li>
<li>Verb [Prepositional Phrase]</li>
<li>[Prepositional Phrase]</li>
</ul>


<p>We shall explore the components of these sentences below, along with what it
means for a
<a href="http://en.wikipedia.org/wiki/Adpositional_phrase#Prepositional_phrases">prepositional phrase</a>
(e.g., &ldquo;to &hellip;&rdquo;, &ldquo;until &hellip;&rdquo;) to stand alone.  The subject is always the
implied &ldquo;you&rdquo; in the imperative.  We are commanding the editor, after all!</p>

<a name="Verbs"></a>
<h3>Verbs</h3>

<p>We have already seen verbs like yank <code>y</code>, change <code>c</code>, put <code>P</code>, and repeat <code>.</code>.
Verbs fall into two categories:  The first type has its &ldquo;area of effect&rdquo;
implied and the change will occur immediately:</p>

<ul>
<li><em>put</em> previously yanked or deleted text <code>P</code></li>
<li><em>repeat</em> last action in a new context <code>.</code></li>
<li><em>delete</em> a single character backwards <code>X</code></li>
<li><em>swap</em> case of a single character <code>~</code></li>
<li><em>insert</em> text <code>i</code></li>
<li><em>replace</em> text <code>R</code></li>
</ul>


<p>The second type is the
<a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#operator"><em>operator</em></a> which
includes commands such as</p>

<ul>
<li>yank <code>y</code></li>
<li>change <code>c</code></li>
<li>delete <code>d</code></li>
<li>increase/decrease indentation <code>&gt;</code> <code>&lt;</code></li>
<li>make UPPER/lower/opposite case <code>gU</code> <code>gu</code> <code>g~</code></li>
</ul>


<p>The difference between &ldquo;immediate changes&rdquo; and operators is that when you type an
operator, the editor awaits the object or region that the operator should
affect.  This role is played by nouns and prepositional phrases.</p>

<p></p>

<p>There are many more verbs, and you indeed need more to use vi (and therefore
Vim) efficiently, but this selection will do fine in explaining the language
metaphor.  It&rsquo;s expected and normal that you find the commands hard to remember
at first.  But if you are curious and/or adamant enough to learn them, they
grow into muscle memory, and you reap the full benefits of the compactness and
efficiency.
<a href="https://sovereign-individual.xyz/posts/why-i-use-vim/">Paraphrasing Pascal Precht</a>:</p>

<blockquote><p>Vim&rsquo;s learning curve is not a curve at all. It&rsquo;s a wall. But once you climb
that wall, you can lean back and slide down on the other side.  Once I was
able to do some basic operations in Vi, I made almost as twice as much
progress at work in about half the time.</p></blockquote>

<p>(If you want some tips on how to edit text better (not just in Vim) and do more
in the same amount of time, Bram Moolenaar, the creator of Vim, has
<a href="https://www.youtube.com/watch?v=p6K4iIMlouI">7 Habits For Effective Text Editing</a>.)</p>

<p>Verbs from both categories (immediate and operators) can involve a mode change.
The insert <code>i</code> and change <code>c</code> commands both switch to insert mode where you can
enter the new text.  The replace <code>R</code> command uses <em>replace mode</em>, which is
similar to insert mode, except you replace (overwrite) text as you type.  (This
is maybe another mode you already knew &ndash; in Microsoft Word and other
<a href="http://en.wikipedia.org/wiki/Word_processor">word processors</a>, it&rsquo;s toggled by the <code>&lt;insert&gt;</code> key.) Operators (as
opposed to immediate changes) in fact always incur mode a change: After typing
the operator, the editor will be in <em>operator pending mode</em>, awaiting the
choice of the text to operate on.  We will see how to choose that text in the
next two sections.</p>

<p></p>

<a name="Nouns.Objects"></a>
<h3>Nouns/Objects</h3>

<p>We have seen nouns such as a paragraph <code>ap</code> and a tag block <code>at</code>.  There are
others such as a word <code>aw</code>, a sentence <code>as</code>, and various blocks (delimited by
 <span class="nobreak"><code>{}</code>,</span>
 <span class="nobreak"><code>()</code>,</span>
 <span class="nobreak"><code>&lt;&gt;</code>,</span>
 <span class="nobreak"><code>[]</code>,</span>
 <span class="nobreak"><code>""</code>,</span>
 <span class="nobreak"><code>''</code>,</span>
 <span class="nobreak">and <code>``</code></span>).
Nouns, or <a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#text-objects">text objects</a> as they are called in Vim, must be prefixed
with an <code>a</code> or <code>i</code>.  Above I showed them with <code>a</code> to help as a mnemonic (&ldquo;a
paragraph&rdquo; ~ <code>ap</code>).  The &ldquo;article&rdquo; serves two purposes: First, it distinguishes
the nouns from <em>prepositional phrases</em> that are bound to the same letter (&ldquo;a
word&rdquo; <code>aw</code>, for example, is not the same as <code>w</code> which means &ldquo;<em>to/until the
next</em> word&rdquo;, as we shall see in the next section).  Second, it marks whether
the whole object (<code>a</code>) or only its &ldquo;insides&rdquo; (<code>i</code>) are meant.  For example, we
have seen <code>yat</code> yank a whole tag block, while <code>cit</code> changes its contents (i.e.,
not the enclosing tags).  For objects that do not have an obvious crunchy shell
surrounding a soft, chewy center, the <code>a</code> version includes the trailing
whitespace while <code>i</code> doesn&rsquo;t.  Thus, <code>a</code> is useful for transplanting words and
sentences without having to clean up the whitespace afterwards.</p>

<p>Text objects are &ldquo;intelligent&rdquo;.  First, they are insensitive to the cursor
position within the text object: The whole object (or its inside) is used as
long as the cursor is somewhere inside it.  Second, they can depend on context:
The meaning of &ldquo;a word&rdquo; depends on the file type.  In C-style programming
languages, dashes are not part of a word, but in Lisps, they are.  For prose
writing, I have set Vim up to see apostrophes as parts of words such that
&ldquo;can&rsquo;t&rdquo; is seen as a single word (which would not be so useful in programming).
Paragraph boundaries can similarly be specified.  Strings are aware of escaped
quote characters.  For example, <code>"This is one \"string\""</code>.</p>

<p>I didn&rsquo;t mention &ldquo;line&rdquo; as a noun.  This is not because operating on lines is
uncommon, in fact it&rsquo;s the opposite.  Repeating an operator symbol makes the
operator work on the current line:
 <span class="nobreak"><code>yy</code>,</span>
 <span class="nobreak"><code>cc</code>,</span>
 <span class="nobreak"><code>dd</code>,</span>
 <span class="nobreak"><code>&gt;&gt;</code>,</span>
 <span class="nobreak"><code>&lt;&lt;</code>,</span>
 <span class="nobreak"><code>gUU</code>,</span>
 <span class="nobreak"><code>guu</code>,</span>
 <span class="nobreak"><code>g~~</code>,</span>
&hellip;</p>

<a name="Prepositional.Phrases.Motions"></a>
<h3>Prepositional Phrases/Motions</h3>

<p>There are also
<a href="http://en.wikipedia.org/wiki/Adpositional_phrase#Prepositional_phrases">prepositional phrases</a>,
which is the grammatical term I use for what Vim calls
<a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#cursor-motions">cursor motions</a>.
We have already seen &ldquo;to the first line&rdquo; and &ldquo;to the last line&rdquo;, <code>gg</code> and <code>G</code>,
respectively.  The sequence <code>ggyG</code> we saw earlier reads as two sentences:
&ldquo;(First,) (go) to the first line of the buffer.  (Then) yank until the last
line.&rdquo;  This demonstrates an important point:
There is no need for punctuation in the &ldquo;vi language&rdquo; (at least figuratively
speaking!) because the word order is enough: A prepositional phrase without
a verb is taken to be a cursor movement command.  A prepositional phrase
following an operator verb means that the operator should act on the text
<em>from</em> the current cursor position and <em>to</em> wherever the motion leads.
(Here you can see that this is really a top-down introduction to Vim.
A tutorial would probably have told you first thing how to move the cursor!)</p>

<p>First, let&rsquo;s see some word motions:</p>

<ul>
<li>&ldquo;to the next beginning-of-a-word&rdquo; <code>w</code></li>
<li>&ldquo;(backwards) to the previous beginning-of-a-word&rdquo; <code>b</code></li>
<li>&ldquo;to the next/previous end-of-a-word&rdquo; <code>e</code> and <code>ge</code></li>
</ul>


<p>Unlike text objects such as &ldquo;a word&rdquo; <code>aw</code>, motions use your exact cursor
position as the point of origin.  Therefore, <code>b</code> and <code>e</code> will find the
beginning/end of the word the cursor is inside, unless you are already on the
beginning/end.  If you <em>are</em> on the beginning or end, they will move to the
previous or next word, respectively.  Notice that I say <em>on</em>.  In Vim/vi, the
cursor moves <em>on</em> characters, not between them as in many other editors.</p>

<p>If you move back and forth in a sentence using <code>b</code> and <code>w</code> you can exploit the
fact that the cursor is always on the first character of a word.  For example,
<code>dw</code> deletes a word without the need for <code>daw</code>.  The motions <code>(</code> and <code>)</code> work
like <code>b</code> and <code>w</code> but for sentences.  The motions <code>{</code> and <code>}</code> go to the
previous/next paragraph boundary.</p>

<p></p>

<p>Another powerful type of motion is the &ldquo;till&rdquo;/&ldquo;find&rdquo; motion. Till <code>t</code> moves to
the next character you specify.  For example, <code>t"</code> moves to right before the
next <code>"</code> in the line.  Find <code>f</code> is similar, except it moves onto the specified
character.  The motion <code>;</code> repeats the last <code>t</code> or <code>f</code> motion.  All three
motions have equivalents going to the left instead of right: <code>T</code>, <code>F</code> and <code>,</code>.</p>

<p>The till/find motions are for quick and simple jumps within the same line.
<a href="http://en.wikipedia.org/wiki/Regular_expression">Regex</a> search finds anything, anywhere in the file.  The commands <code>/</code>
and <code>?</code> open up a search field for forward and backward regex search,
respectively.  It even highlights the first match while you type to give you
live feedback on your search pattern.  After confirming the entered pattern
with <code>&lt;enter&gt;</code>, keys <code>n</code> and <code>N</code> jump in the same/opposite direction of the
current regex search.</p>

<p>Coming from other text editors, it&rsquo;s easy to think that <code>/</code> is &ldquo;just&rdquo; how you
search for text.  And it is.  But the four commands <span class="nobreak"><code>/</code>
<code>?</code> <code>n</code> <code>N</code></span> are all motions, and like any motion they can be used alone
or with an operator.  The design of vi is <a href="http://en.wikipedia.org/wiki/Orthogonality#Computer_science">orthogonal</a>:  You can learn
it piece by piece, and combine the new motion you just learned with the verbs
you already knew and vice versa.  This is extremely powerful and part of what
makes vi/Vim so special.  The idea may be almost 40 years old, but
<a href="https://medium.com/@mkozlows/why-atom-cant-replace-vim-433852f4b4d1">it&rsquo;s still relevant today and in the future</a>!</p>

<p>You may have noticed I didn&rsquo;t mention the most basic motions you already know
from your arrow keys.  Many Vim introductions (including the official
&ldquo;vimtutor&rdquo;) mention very early on that <span class="nobreak"><code>h</code> <code>j</code> <code>k</code> <code>l</code>
</span> work as <span class="nobreak">&#8592; &#8595; &#8593; &#8594;</span>,
respectively.  And people wonder why they can&rsquo;t just use the normal arrow keys.
But either kind of arrow keys are beside the point!  There&rsquo;s almost always
a smarter way &mdash; a more precise motion &mdash; to go somewhere than to hold down
arrow keys.  <a href="https://jeetblogs.org/post/vim-making-those-arrow-keys-work-for-you-or-why-the-anti-arrow-key-propoganda-is-wrong/">Jeet Sukumaran tells it</a> again:</p>

<blockquote><p>being forced to use the rich suite of powerful normal mode movement commands
to get to exactly where I needed to be [&hellip;] was like
suddenly beginning to use the fifth and other gears while driving on an open
highway, whereas before I had been grinding along for mile after laborious
mile on first.</p></blockquote>

<p>Here are some more motions just to illustrate:</p>

<ul>
<li>&ldquo;to the matching parenthesis/brace/comment marker/HTML tag/if/else-stmt/etc. <code>%</code></li>
<li>&ldquo;to the next/previous misspelled word&rdquo; <code>]s</code> <code>[s</code></li>
<li>&ldquo;to the next/previous start/end of a method (Java style) <code>]m</code> <code>]M</code> <code>[m</code> <code>[M</code></li>
</ul>


<p></li>
</ul>


<a name="Numerals"></a>
<h3>Numerals</h3>

<p>So far we have covered verbs, nouns, and prepositional phrases. Let&rsquo;s look at
numerals, of which vi uses three types:</p>

<ul>
<li>Cardinal numbers, e.g., 1, 2, 7</li>
<li>Adverbial numbers, e.g., once, twice, sevenfold</li>
<li>Ordinal numbers, e.g. 1st, 2nd, 7th</li>
</ul>


<p>The grammatical distinction is mine; in vi they&rsquo;re all known as <em>counts</em>.  But
it helps to show the different roles counts have.
Cardinal numbers (1, 2, 7) can choose the number of lines to apply an operator
to, or the number of text objects (nouns) to apply an operator to:</p>

<ul>
<li>&ldquo;Indent ten lines&rdquo; <code>10&gt;&gt;</code></li>
<li>&ldquo;Uppercase two sentences&rdquo; <code>gU2as</code></li>
</ul>


<p>Adverbial numbers (once, twice, sevenfold) can decide the number of times to
do something:</p>

<ul>
<li>&ldquo;Twentyfold insert a blank line&rdquo; <code>20i&lt;enter&gt;&lt;esc&gt;</code> (-> &ldquo;Insert 20 blank
lines&rdquo;)</li>
<li>&ldquo;Delete until you have moved twice to the next word&rdquo; <code>d2w</code> (-> &ldquo;Delete two
words&rdquo;)</li>
</ul>


<p>Ordinal numbers (1st, 2nd, 7th) can choose where to go:</p>

<ul>
<li>&ldquo;To the 27th line&rdquo; <code>27gg</code></li>
<li>&ldquo;To the 20000th byte&rdquo; <code>20000go</code></li>
<li>&ldquo;To the 80&#8217;th column&rdquo; <code>80|</code></li>
<li>&ldquo;To the 70%&lsquo;th line&rdquo; <code>70%</code></li>
</ul>


<p>The ordinal numbers can also be though of just as cardinals (line 27 = 27th
line), but since they access ordered items, it makes sense to see them as
ordinals.</p>

<p>All motions and operators in fact take a count, but it usually defaults to 1.
This is another example of orthogonality in vi.</p>

<p></p>

<a name="Expand.your.Vocabulary"></a>
<h2>Expand your Vocabulary</h2>

<p>For even more orthogonality, you can even add verbs and nouns, as
<a href="http://yanpritzker.com/2011/12/16/learn-to-speak-vim-verbs-nouns-and-modifiers/">mentioned by Yan Pritzker</a>:</p>

<ul>
<li>Install Drew Niel&rsquo;s
<a href="https://github.com/nelstrom/vim-textobj-rubyblock">textobj-rubyblock</a>
plugin to get the new noun &ldquo;Ruby block&rdquo; <code>r</code>.</li>
<li>Install Tim Pope&rsquo;s <a href="https://github.com/tpope/vim-surround">surround.vim</a>
plugin to get three new verbs:

<ul>
<li>&ldquo;Surround with&rdquo;, which is even HTML aware (closes tags). Example:

<ul>
<li>&ldquo;(you) surround a word with em-tags <code>ysaw&lt;em&gt;</code></li>
</ul>
</li>
<li>&ldquo;Change surroundings&rdquo;, example:

<ul>
<li>&ldquo;change the nearest surrounding single quotes to double quotes&rdquo; <code>cs'"</code></li>
</ul>
</li>
<li>&ldquo;Delete surroundings&rdquo;, e.g.

<ul>
<li>&ldquo;delete the nearest surrounding asterisks&rdquo; <code>ds*</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<p></p>

<p></p>

<a name="Real.Keyboard.Shortcuts"></a>
<h2>Real Keyboard Shortcuts</h2>

<p></p>

<p>The key <code>y</code> is not a shortcut for yank, it <em>is</em> the yank operator.  But vi
still has shortcuts (in the traditional sense of the word) for those actions
that are so common that having a shorter ways to get to them is useful:</p>

<ul>
<li>&ldquo;Delete left/right&rdquo; <code>dh</code> and <code>dl</code> are <code>X</code> and <code>x</code> (think backspace and
delete)</li>
<li>&ldquo;Change to the end of the line&rdquo; <code>c$</code> is <code>C</code></li>
<li>&ldquo;Delete to the end of the line&rdquo; <code>d$</code> is <code>D</code></li>
</ul>


<p>Recall that <code>$</code> means &ldquo;to the end of the line&rdquo;.  Similarly, <code>0</code> means &ldquo;to the
beginning of the line&rdquo; and <code>^</code> means &ldquo;to the first non-blank character on the
line&rdquo;. With these we get:</p>

<ul>
<li>&ldquo;Insert at the &#8220;beginning&rdquo; of the line&#8221; <code>^i</code> is <code>I</code></li>
<li>&ldquo;Really insert at the beginning of the line!&rdquo; <code>0i</code> is <code>gI</code></li>
<li>&ldquo;Append to the line&rdquo; <code>$a</code> is <code>A</code>  (append <code>a</code> is like insert <code>i</code>
except it inserts <em>after</em> the cursor position)</li>
</ul>


<p>The idea that &ldquo;vi is about pressing <code>i</code> to insert text&rdquo; is wrong.  We have
already seen that it takes focus away from what vi is really about, namely
actions.  But it&rsquo;s also wrong because it takes focus away from the above
insertion commands which are just as common as <code>i</code> for the effective user.  For
programmers, one type of action is even more common:</p>

<ul>
<li>&ldquo;Open a new line below&rdquo; <code>o</code></li>
<li>&ldquo;Open a new line above&rdquo; <code>O</code></li>
</ul>


<p>It inserts a blank line and leaves you in insert mode, ready to type a new
statement in your program.  With Vim&rsquo;s indentation features this even starts
inserting at the right indentation level, aware of nesting and control
structures. For example, if the previous line is an &ldquo;if&rdquo; statement or the start
of a new block, the next line&rsquo;s indentation level should be one higher.</p>

<p></p>

<a name="What.about.Usability."></a>
<h2>What about Usability?</h2>

<p>I figure I should mention usability because there could seem to be a conflict
between these two facts: (1) I care about usability, and (2) vi is definitely
not known to be user friendly. How can I reconcile this?  The thing to remember
is that usability is about more than user friendliness.  Using the first two
components of <a href="http://www.nngroup.com/articles/usability-101-introduction-to-usability/">Jakob Nielsen&rsquo;s definition of usability</a>:</p>

<ul>
<li><em><strong>Learnability</strong>: How easy is it for users to accomplish basic tasks the first time they encounter the design?</em></li>
<li><em><strong>Efficiency</strong>: Once users have learned the design, how quickly can they perform tasks?</em></li>
</ul>


<p>This is the fundamental trade-off with Vim/vi: Very hard to master and very
efficient when mastered.  The question then quickly arises: Can learnability be
improved without harming efficiency?  And what other options exist on the
learnability/efficiency plane?  (And what about the other aspects of
usability?)  These are all interesting topics for another time!  In the
meantime I hope the <a href="http://www.nngroup.com/articles/mental-models/">mental model</a> of vi explained in this post will
make, if not your first, then your next encounter with Vim more meaningful.</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>The essence of vi is not modality.  The essence of vi is performing actions on
text.  Actions are specified using an extensible and orthogonally composable
&ldquo;language&rdquo;, where the same motions that are part of actions are also used for
plain cursor movement.  Some of the actions involve mode switching, some don&rsquo;t.
The actions drive the editing process while the modes help put a large
vocabulary right under your fingertips.</p>

<p></p>

<p>I have only covered basic text manipulation, though Vim does much more.  Any
user would need to know how to open/close/save files, and maybe
open/close/switch buffers, windows, and tabs (Vim has them all).  Fancier
features include regex substitution, autocompletion, diff mode, scripting, key
remapping, (mutually recursive) macros, persistent undo, and encryption.</p>

<p>These features add tremendously to the usefulness of Vim.  And regex
substitution predates even vi.  But in my opinion they are not part of its
essence, action based editing.  In fact, I barely touched upon the
command-line/Ex mode.  Most people who have tried Vim know it because it is the
one you enter when you type <code>:w&lt;enter&gt;</code> to save and <code>:q&lt;enter&gt;</code> to quit.</p>

<p>Is command-line mode essential?
Maybe <a href="http://blog.sanctum.geek.nz/vim-koans/">the Vim Koan &ldquo;The superior editor&rdquo;</a> will enlighten you.</p>

<p><em>Update 2016-04-27: Motions <code>]m</code> <code>]M</code> <code>[m</code> <code>[M</code> do unfortunately not work for
C# out of the box. Also, grammar fixes.</em></p>

<p><em>Update 2021-06-26: Fix dead links.</em></p>

<p></p>
]]></content>
  </entry>
  
</feed>
